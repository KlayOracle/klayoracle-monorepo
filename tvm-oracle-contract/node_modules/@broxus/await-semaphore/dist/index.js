"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mutex = exports.Semaphore = void 0;
function ensureCallable(fn) {
    if (typeof fn !== 'function')
        throw new TypeError(fn + " is not a function");
    return fn;
}
function byObserver(Observer) {
    const node = document.createTextNode('');
    let queue, currentQueue, bit = 0, i = 0;
    new Observer(function () {
        let callback;
        if (!queue) {
            if (!currentQueue)
                return;
            queue = currentQueue;
        }
        else if (currentQueue) {
            queue = currentQueue.slice(i).concat(queue);
        }
        currentQueue = queue;
        queue = null;
        i = 0;
        if (typeof currentQueue === 'function') {
            callback = currentQueue;
            currentQueue = null;
            callback();
            return;
        }
        node.data = (bit = ++bit % 2); // Invoke other batch, to handle leftover callbacks in case of crash
        while (i < currentQueue.length) {
            callback = currentQueue[i];
            i++;
            if (i === currentQueue.length)
                currentQueue = null;
            callback();
        }
    }).observe(node, { characterData: true });
    return function (fn) {
        ensureCallable(fn);
        if (queue) {
            if (typeof queue === 'function')
                queue = [queue, fn];
            else
                queue.push(fn);
            return;
        }
        queue = fn;
        node.data = (bit = ++bit % 2);
    };
}
const nextTick = (function () {
    // queueMicrotask
    if (typeof queueMicrotask === "function") {
        return function (cb) {
            queueMicrotask(ensureCallable(cb));
        };
    }
    // MutationObserver
    if ((typeof document === 'object') && document) {
        if (typeof MutationObserver === 'function')
            return byObserver(MutationObserver);
        if (typeof window.WebKitMutationObserver === 'function')
            return byObserver(window.WebKitMutationObserver);
    }
    // W3C Draft
    // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
    if (typeof setImmediate === 'function') {
        return function (cb) {
            setImmediate(ensureCallable(cb));
        };
    }
    // Wide available standard
    if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {
        return function (cb) {
            setTimeout(ensureCallable(cb), 0);
        };
    }
    throw new Error('No `nextTick` implementation found');
}());
class Semaphore {
    constructor(count) {
        this.tasks = [];
        this.count = count;
    }
    sched() {
        if (this.count > 0 && this.tasks.length > 0) {
            this.count--;
            let next = this.tasks.shift();
            if (next === undefined) {
                throw "Unexpected undefined value in tasks list";
            }
            next();
        }
    }
    acquire() {
        return new Promise((res, _rej) => {
            const task = () => {
                let released = false;
                res(() => {
                    if (!released) {
                        released = true;
                        this.count++;
                        this.sched();
                    }
                });
            };
            this.tasks.push(task);
            nextTick(this.sched.bind(this));
        });
    }
    use(f) {
        return this.acquire()
            .then(release => {
            return f()
                .then((res) => {
                release();
                return res;
            })
                .catch((err) => {
                release();
                throw err;
            });
        });
    }
}
exports.Semaphore = Semaphore;
class Mutex extends Semaphore {
    constructor() {
        super(1);
    }
}
exports.Mutex = Mutex;
