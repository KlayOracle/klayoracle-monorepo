import { Address, UniqueArray } from './utils';
import { AbiFunction, AbiEvent, AbiFields, FullContractState, Transaction, AbiFunctionName, AbiEventName, AbiFieldName, AbiFunctionInputs, DecodedAbiFunctionOutputs, DecodedAbiFunctionInputs, DecodedAbiFields, AbiFunctionInputsWithDefault, DecodedAbiEventData, TransactionId } from './models';
import { Stream, Subscriber } from './stream';
import { ProviderApiResponse, ProviderRpcClient } from './index';
/**
 * @category Contract
 */
export declare class Contract<Abi> {
    private readonly _provider;
    private readonly _abi;
    private readonly _address;
    private readonly _methods;
    private readonly _fields;
    readonly methodsAbi: {
        [K in AbiFunctionName<Abi>]: AbiFunction<Abi, K>;
    };
    readonly eventsAbi: {
        [K in AbiEventName<Abi>]: AbiEvent<Abi, K>;
    };
    readonly fieldsAbi: AbiFields<Abi>;
    constructor(provider: ProviderRpcClient, abi: Abi, address: Address);
    get methods(): ContractMethods<Abi>;
    get fields(): ContractFields<Abi>;
    get address(): Address;
    get abi(): string;
    /**
     * Requests contract data
     *
     * ---
     * Required permissions: `basic`
     */
    getFullState(): Promise<ProviderApiResponse<'getFullContractState'>>;
    /**
     * Unpacks all fields from the contract state using the specified ABI
     *
     * ---
     * Required permissions: `basic`
     */
    getFields(args?: GetContractFieldsParams): Promise<{
        fields?: DecodedAbiFields<Abi>;
        state?: FullContractState;
    }>;
    /**
     * Creates new contract transactions stream
     *
     * @param subscriber
     */
    transactions(subscriber: Subscriber): Stream<unknown, Transaction>;
    /**
     * Creates new contract events stream
     *
     * @param subscriber
     */
    events(subscriber: Subscriber): Stream<unknown, DecodedEventWithTransaction<Abi, AbiEventName<Abi>>>;
    waitForEvent<E extends AbiEventName<Abi> = AbiEventName<Abi>>(args?: WaitForEventParams<Abi, E>): Promise<DecodedEvent<Abi, E> | undefined>;
    getPastEvents<E extends AbiEventName<Abi> = AbiEventName<Abi>>(args: GetPastEventParams<Abi, E>): Promise<EventsBatch<Abi, E>>;
    decodeTransaction(args: DecodeTransactionParams<Abi>): Promise<DecodedTransaction<Abi, AbiFunctionName<Abi>> | undefined>;
    decodeTransactionEvents(args: DecodeTransactionEventsParams): Promise<DecodedEvent<Abi, AbiEventName<Abi>>[]>;
    decodeInputMessage(args: DecodeInputParams<Abi>): Promise<DecodedInput<Abi, AbiFunctionName<Abi>> | undefined>;
    decodeOutputMessage(args: DecodeOutputParams<Abi>): Promise<DecodedOutput<Abi, AbiFunctionName<Abi>> | undefined>;
    decodeEvent(args: DecodeEventParams<Abi>): Promise<DecodedEvent<Abi, AbiEventName<Abi>> | undefined>;
}
/**
 * @category Contract
 */
export declare class TvmException extends Error {
    readonly code: number;
    constructor(code: number);
}
/**
 * @category Contract
 */
export declare type DelayedMessageExecution = {
    /**
     * External message hash
     */
    messageHash: string;
    /**
     * Message expiration timestamp
     */
    expireAt: number;
    /**
     * Transaction promise (it will be rejected if the message has expired)
     */
    transaction: Promise<Transaction>;
};
/**
 * @category Contract
 */
export declare type ContractMethods<C> = {
    [K in AbiFunctionName<C>]: (params: AbiFunctionInputsWithDefault<C, K>) => ContractMethod<AbiFunctionInputs<C, K>, DecodedAbiFunctionOutputs<C, K>>;
};
/**
 * @category Contract
 */
export declare type ContractFields<C> = {
    [K in AbiFieldName<C>]: (params?: GetContractFieldsParams) => Promise<DecodedAbiFields<C>[K]>;
};
/**
 * @category Contract
 */
export interface ContractMethod<I, O> {
    /**
     * Target contract address
     */
    readonly address: Address;
    readonly abi: string;
    readonly method: string;
    readonly params: I;
    /**
     * Sends internal message and returns wallet transaction
     *
     * @param args
     */
    send(args: SendInternalParams): Promise<Transaction>;
    /**
     * Sends internal message without waiting for the transaction
     *
     * @param args
     */
    sendDelayed(args: SendInternalParams): Promise<DelayedMessageExecution>;
    /**
     * Sends internal message and waits for the new transaction on target address
     *
     * @param args
     */
    sendWithResult(args: SendInternalParams): Promise<{
        parentTransaction: Transaction;
        childTransaction: Transaction;
        output?: O;
    }>;
    /**
     * Estimates wallet fee for calling this method as an internal message
     *
     * @param args
     */
    estimateFees(args: SendInternalParams): Promise<string>;
    /**
     * Sends external message and returns contract transaction with parsed output
     *
     * @param args
     */
    sendExternal(args: SendExternalParams): Promise<{
        transaction: Transaction;
        output?: O;
    }>;
    /**
     * Sends external message without waiting for the transaction
     *
     * @param args
     */
    sendExternalDelayed(args: SendExternalDelayedParams): Promise<DelayedMessageExecution>;
    /**
     * Executes only a compute phase locally
     *
     * @param args
     */
    call(args?: CallParams): Promise<O>;
    /**
     * Encodes this method as an external message and
     * executes all transaction phases locally, producing a new state
     */
    executeExternal(args: ExecuteExternalParams): Promise<ExecutorOutput<O>>;
    /**
     * Encodes this method as an internal message and
     * executes all transaction phases locally, producing a new state
     */
    executeInternal(args: ExecuteInternalParams): Promise<ExecutorOutput<O>>;
    /**
     * Encodes method call as BOC
     */
    encodeInternal(): Promise<string>;
}
/**
 * @category Contract
 */
export declare type GetContractFieldsParams = {
    /**
     * Cached contract state
     */
    cachedState?: FullContractState;
    /**
     * Don't fail if something is left in a cell after unpacking
     */
    allowPartial?: boolean;
};
/**
 * @category Contract
 */
export declare type SendInternalParams = {
    /**
     * Preferred wallet address.
     * It is the same address as the `accountInteraction.address`, but it must be explicitly provided
     */
    from: Address;
    /**
     * Amount of nano EVER to send
     */
    amount: string;
    /**
     * @default true
     */
    bounce?: boolean;
    /**
     * Optional base64 encoded TVC
     *
     * NOTE: If the selected contract do not support stateInit in the internal message,
     * an error is returned
     */
    stateInit?: string;
};
/**
 * @category Contract
 */
export declare type SendInternalWithResultParams = SendInternalParams & {
    /**
     * Existing subscriber
     */
    subscriber?: Subscriber;
};
/**
 * @category Contract
 */
export declare type SendExternalParams = ({
    /**
     * Whether to prepare this message without signature. Default: false
     */
    withoutSignature: true;
} | {
    /**
     * The public key of the preferred account.
     * It is the same publicKey as the `accountInteraction.publicKey`, but it must be explicitly provided
     */
    publicKey: string;
    /**
     * Whether to prepare this message without signature. Default: false
     */
    withoutSignature?: false;
}) & {
    /**
     * Optional base64 encoded TVC
     */
    stateInit?: string;
    /**
     * Whether to run this message locally. Default: false
     */
    local?: boolean;
    /**
     * Optional executor parameters used during local contract execution
     */
    executorParams?: {
        /**
         * If `true`, signature verification always succeds
         */
        disableSignatureCheck?: boolean;
        /**
         * Explicit account balance in nano EVER
         */
        overrideBalance?: string | number;
    };
};
/**
 * @category Contract
 */
export declare type SendExternalDelayedParams = {
    /**
     * The public key of the preferred account.
     * It is the same publicKey as the `accountInteraction.publicKey`, but it must be explicitly provided
     */
    publicKey: string;
    /**
     * Optional base64 encoded TVC
     */
    stateInit?: string;
};
/**
 * @category Contract
 */
export declare type CallParams = {
    /**
     * Cached contract state
     */
    cachedState?: FullContractState;
    /**
     * Whether to run the method locally as responsible.
     *
     * This will use internal message with unlimited account balance.
     */
    responsible?: boolean;
};
/**
 * @category Contract
 */
export declare type ExecuteExternalParams = {
    /**
     * Cached contract state
     */
    cachedState?: FullContractState;
    /**
     * The public key of the signer.
     */
    publicKey: string;
    /**
     * Optional base64 encoded TVC
     */
    stateInit?: string;
    /**
     * Optional executor parameters used during local contract execution
     */
    executorParams?: {
        /**
         * If `true`, signature verification always succeeds
         */
        disableSignatureCheck?: boolean;
        /**
         * Explicit account balance in nano EVER
         */
        overrideBalance?: string | number;
    };
    /**
     * Whether to prepare this message without signature. Default: false
     */
    withoutSignature?: boolean;
};
/**
 * @category Contract
 */
export declare type ExecuteInternalParams = {
    /**
     * Cached contract state
     */
    cachedState?: FullContractState;
    /**
     * Optional base64 encoded TVC
     */
    stateInit?: string;
    /**
     * Message source address
     */
    sender: Address;
    /**
     * Amount of nano EVER to attach to the message
     */
    amount: string;
    /**
     * Whether to bounce message back on error. Default: false
     */
    bounce?: boolean;
    /**
     * Whether the constructed message is bounced. Default: false
     */
    bounced?: boolean;
    /**
     * Optional executor parameters used during local contract execution
     */
    executorParams?: {
        /**
         * If `true`, signature verification always succeeds
         */
        disableSignatureCheck?: boolean;
        /**
         * Explicit account balance in nano EVER
         */
        overrideBalance?: string | number;
    };
};
/**
 * @category Contract
 */
export declare type GetPastEventParams<Abi, E extends AbiEventName<Abi>> = {
    filter?: E | EventsFilter<Abi, AbiEventName<Abi>>;
    range?: EventsRange;
    limit?: number;
    continuation?: TransactionId;
};
/**
 * @category Contract
 */
export declare type WaitForEventParams<Abi, E extends AbiEventName<Abi>> = {
    filter?: E | EventsFilter<Abi, E>;
    range?: EventsRange;
    subscriber?: Subscriber;
};
/**
 * @category Contract
 */
export declare type EventsBatch<Abi, E extends AbiEventName<Abi>> = {
    events: DecodedEventWithTransaction<Abi, E>[];
    continuation?: TransactionId;
};
/**
 * @category Contract
 */
export declare type EventsFilter<Abi, E extends AbiEventName<Abi> = AbiEventName<Abi>> = (event: DecodedEventWithTransaction<Abi, E>) => Promise<boolean> | boolean;
/**
 * @category Contract
 */
export declare type DecodedEventWithTransaction<Abi, E extends AbiEventName<Abi>> = DecodedEvent<Abi, E> & {
    transaction: Transaction;
};
/**
 * @category Contract
 */
export declare type EventsRange = {
    fromLt?: string;
    fromUtime?: number;
    toLt?: string;
    toUtime?: number;
};
/**
 * @category Contract
 */
export declare type DecodeTransactionParams<Abi> = {
    transaction: Transaction;
    methods: UniqueArray<AbiFunctionName<Abi>[]>;
};
/**
 * @category Contract
 */
export declare type DecodedTransaction<Abi, T> = T extends AbiFunctionName<Abi> ? {
    method: T;
    input: DecodedAbiFunctionInputs<Abi, T>;
    output: DecodedAbiFunctionOutputs<Abi, T>;
} : never;
/**
 * @category Contract
 */
export declare type DecodeInputParams<Abi> = {
    body: string;
    methods: UniqueArray<AbiFunctionName<Abi>[]>;
    internal: boolean;
};
/**
 * @category Contract
 */
export declare type DecodedInput<Abi, T> = T extends AbiFunctionName<Abi> ? {
    method: T;
    input: DecodedAbiFunctionInputs<Abi, T>;
} : never;
/**
 * @category Contract
 */
export declare type DecodeOutputParams<Abi> = {
    /**
     * Base64 encoded message body BOC
     */
    body: string;
    methods: UniqueArray<AbiFunctionName<Abi>[]>;
};
/**
 * @category Contract
 */
export declare type DecodeEventParams<Abi> = {
    /**
     * Base64 encoded message body BOC
     */
    body: string;
    events: UniqueArray<AbiEventName<Abi>[]>;
};
/**
 * @category Contract
 */
export declare type DecodedOutput<Abi, T> = T extends AbiFunctionName<Abi> ? {
    method: T;
    output: DecodedAbiFunctionOutputs<Abi, T>;
} : never;
/**
 * @category Contract
 */
export declare type DecodeTransactionEventsParams = {
    transaction: Transaction;
};
/**
 * @category Contract
 */
export declare type DecodedEvent<Abi, T> = T extends AbiEventName<Abi> ? {
    event: T;
    data: DecodedAbiEventData<Abi, T>;
} : never;
/**
 * @category Contract
 */
export declare type ExecutorOutput<O> = {
    /**
     * Executed transaction
     */
    transaction: Transaction;
    /**
     * Contract state after the executed transaction
     */
    newState: FullContractState | undefined;
    /**
     * Parsed function call output
     */
    output: O | undefined;
};
