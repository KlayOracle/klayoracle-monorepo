"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TvmException = exports.Contract = void 0;
const utils_1 = require("./utils");
const models_1 = require("./models");
/**
 * @category Contract
 */
class Contract {
    constructor(provider, abi, address) {
        if (!Array.isArray(abi.functions)) {
            throw new Error('Invalid abi. Functions array required');
        }
        if (!Array.isArray(abi.events)) {
            throw new Error('Invalid abi. Events array required');
        }
        this._provider = provider;
        this._abi = JSON.stringify(abi);
        this.methodsAbi = abi.functions.reduce((functions, item) => {
            if (item.inputs == null) {
                item.inputs = [];
            }
            if (item.outputs == null) {
                item.outputs = [];
            }
            functions[item.name] = item;
            return functions;
        }, {});
        this.eventsAbi = abi.events.reduce((events, item) => {
            if (item.inputs == null) {
                item.inputs = [];
            }
            events[item.name] = item;
            return events;
        }, {});
        this.fieldsAbi = abi.fields;
        this._address = address;
        this._methods = new Proxy({}, {
            get: (_object, method) => {
                const rawAbi = this.methodsAbi[method];
                return (params = {}) => new ContractMethodImpl(this._provider, rawAbi, this._abi, this._address, method, params);
            },
        });
        this._fields = new Proxy({}, {
            get: (_object, field) => {
                return async (params = {}) => {
                    await this._provider.ensureInitialized();
                    const { fields, state } = await this._provider.rawApi.getContractFields({
                        address: this._address.toString(),
                        abi: this._abi,
                        cachedState: params === null || params === void 0 ? void 0 : params.cachedState,
                        allowPartial: (params === null || params === void 0 ? void 0 : params.allowPartial) == null ? false : params.allowPartial,
                    });
                    if (fields == null) {
                        if (state == null) {
                            throw new Error('Account does not exist');
                        }
                        else if (!state.isDeployed) {
                            throw new Error('Account is not deployed');
                        }
                        else {
                            throw new Error('Invalid account data');
                        }
                    }
                    const parsedFields = (0, models_1.parseTokensObject)(this.fieldsAbi, fields);
                    if (parsedFields == null || !Object.prototype.hasOwnProperty.call(parsedFields, field)) {
                        throw new Error('Unknown field');
                    }
                    return parsedFields[field];
                };
            },
        });
    }
    get methods() {
        return this._methods;
    }
    get fields() {
        return this._fields;
    }
    get address() {
        return this._address;
    }
    get abi() {
        return this._abi;
    }
    /**
     * Requests contract data
     *
     * ---
     * Required permissions: `basic`
     */
    async getFullState() {
        await this._provider.ensureInitialized();
        return (await this._provider.rawApi.getFullContractState({
            address: this.address.toString(),
        }));
    }
    /**
     * Unpacks all fields from the contract state using the specified ABI
     *
     * ---
     * Required permissions: `basic`
     */
    async getFields(args = {}) {
        await this._provider.ensureInitialized();
        const { fields, state } = await this._provider.rawApi.getContractFields({
            address: this.address.toString(),
            abi: this._abi,
            cachedState: args.cachedState,
            allowPartial: args.allowPartial == null ? false : args.allowPartial,
        });
        return {
            fields: fields != null ? (0, models_1.parseTokensObject)(this.fieldsAbi, fields) : undefined,
            state,
        };
    }
    /**
     * Creates new contract transactions stream
     *
     * @param subscriber
     */
    transactions(subscriber) {
        return subscriber.transactions(this._address).flatMap(({ transactions }) => transactions);
    }
    /**
     * Creates new contract events stream
     *
     * @param subscriber
     */
    events(subscriber) {
        return subscriber
            .transactions(this._address)
            .flatMap(({ transactions }) => transactions)
            .flatMap(tx => this.decodeTransactionEvents({ transaction: tx }).then(events => {
            events.forEach(event => (event.transaction = tx));
            return events;
        }));
    }
    async waitForEvent(args = {}) {
        const { range, filter } = args;
        const filterFn = typeof filter === 'string'
            ? ({ event }) => event === filter
            : filter;
        let subscriber = args.subscriber;
        const hasTempSubscriber = subscriber == null;
        if (subscriber == null) {
            subscriber = new this._provider.Subscriber();
        }
        const event = await ((range === null || range === void 0 ? void 0 : range.fromLt) != null || (range === null || range === void 0 ? void 0 : range.fromUtime) != null
            ? subscriber.oldTransactions(this._address, range).merge(subscriber.transactions(this._address))
            : subscriber.transactions(this.address))
            .flatMap(item => item.transactions)
            .takeWhile(item => range == null ||
            ((range.fromLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.fromLt) > 0) &&
                (range.fromUtime == null || item.createdAt > range.fromUtime) &&
                (range.toLt == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.toLt) < 0) &&
                (range.toUtime == null || item.createdAt < range.toUtime)))
            .flatMap(tx => this.decodeTransactionEvents({ transaction: tx }).then(events => {
            events.forEach(event => (event.transaction = tx));
            return events;
        }))
            .filterMap(async (event) => {
            if (filterFn == null || (await filterFn(event))) {
                return event;
            }
            else {
                return undefined;
            }
        })
            .first();
        hasTempSubscriber && (await subscriber.unsubscribe());
        return event;
    }
    async getPastEvents(args) {
        const { range, filter, limit } = args;
        const filterFn = typeof filter === 'string'
            ? ({ event }) => event === filter
            : filter;
        const result = [];
        let currentContinuation = args === null || args === void 0 ? void 0 : args.continuation;
        outer: while (true) {
            const { transactions, continuation } = await this._provider.getTransactions({
                address: this._address,
                continuation: currentContinuation,
            });
            if (transactions.length === null) {
                break;
            }
            const filteredTransactions = transactions.filter(item => ((range === null || range === void 0 ? void 0 : range.fromLt) == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.fromLt) > 0) &&
                ((range === null || range === void 0 ? void 0 : range.fromUtime) == null || item.createdAt > range.fromUtime) &&
                ((range === null || range === void 0 ? void 0 : range.toLt) == null || utils_1.LT_COLLATOR.compare(item.id.lt, range.toLt) < 0) &&
                ((range === null || range === void 0 ? void 0 : range.toUtime) == null || item.createdAt < range.toUtime));
            if (filteredTransactions.length > 0) {
                const parsedEvents = await Promise.all(filteredTransactions.map(async (tx) => {
                    return {
                        tx,
                        events: await this.decodeTransactionEvents({ transaction: tx }).then(events => {
                            events.forEach(event => (event.transaction = tx));
                            return events;
                        }),
                    };
                }));
                for (let { tx, events } of parsedEvents) {
                    if (filterFn != null) {
                        events = await Promise.all(events.map(async (event) => ((await filterFn(event)) ? event : undefined))).then(events => events.filter((event) => event != null));
                    }
                    currentContinuation = tx.id; // update continuation in case of early break
                    for (const event of events) {
                        if (limit != null && result.length >= limit) {
                            break outer;
                        }
                        result.push(event);
                    }
                    if (limit != null && result.length >= limit) {
                        break outer;
                    }
                }
            }
            currentContinuation = continuation;
            if (currentContinuation == null) {
                break;
            }
        }
        return { events: result, continuation: currentContinuation };
    }
    async decodeTransaction(args) {
        await this._provider.ensureInitialized();
        try {
            const result = await this._provider.rawApi.decodeTransaction({
                transaction: (0, models_1.serializeTransaction)(args.transaction),
                abi: this._abi,
                method: args.methods,
            });
            if (result == null) {
                return undefined;
            }
            const { method, input, output } = result;
            const rawAbi = this.methodsAbi[method];
            return {
                method,
                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},
                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},
            };
        }
        catch (_) {
            return undefined;
        }
    }
    async decodeTransactionEvents(args) {
        await this._provider.ensureInitialized();
        try {
            const { events } = await this._provider.rawApi.decodeTransactionEvents({
                transaction: (0, models_1.serializeTransaction)(args.transaction),
                abi: this._abi,
            });
            const result = [];
            for (const { event, data } of events) {
                const rawAbi = this.eventsAbi[event];
                result.push({
                    event,
                    data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {},
                });
            }
            return result;
        }
        catch (_) {
            return [];
        }
    }
    async decodeInputMessage(args) {
        await this._provider.ensureInitialized();
        try {
            const result = await this._provider.rawApi.decodeInput({
                abi: this._abi,
                body: args.body,
                internal: args.internal,
                method: args.methods,
            });
            if (result == null) {
                return undefined;
            }
            const { method, input } = result;
            const rawAbi = this.methodsAbi[method];
            return {
                method,
                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},
            };
        }
        catch (_) {
            return undefined;
        }
    }
    async decodeOutputMessage(args) {
        await this._provider.ensureInitialized();
        try {
            const result = await this._provider.rawApi.decodeOutput({
                abi: this._abi,
                body: args.body,
                method: args.methods,
            });
            if (result == null) {
                return undefined;
            }
            const { method, output } = result;
            const rawAbi = this.methodsAbi[method];
            return {
                method,
                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},
            };
        }
        catch (_) {
            return undefined;
        }
    }
    async decodeEvent(args) {
        await this._provider.ensureInitialized();
        try {
            const result = await this._provider.rawApi.decodeEvent({
                abi: this.abi,
                body: args.body,
                event: args.events,
            });
            if (result == null) {
                return undefined;
            }
            const { event, data } = result;
            const rawAbi = this.eventsAbi[event];
            return {
                event,
                data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {},
            };
        }
        catch (_) {
            return undefined;
        }
    }
}
exports.Contract = Contract;
/**
 * @category Contract
 */
class TvmException extends Error {
    constructor(code) {
        super(`TvmException: ${code}`);
        this.code = code;
    }
}
exports.TvmException = TvmException;
class ContractMethodImpl {
    constructor(provider, functionAbi, abi, address, method, params) {
        this.provider = provider;
        this.functionAbi = functionAbi;
        this.abi = abi;
        this.address = address;
        this.method = method;
        this.params = (0, models_1.serializeTokensObject)(params);
    }
    async send(args) {
        await this.provider.ensureInitialized();
        const { transaction } = await this.provider.rawApi.sendMessage({
            sender: args.from.toString(),
            recipient: this.address.toString(),
            amount: args.amount,
            bounce: args.bounce == null ? true : args.bounce,
            payload: {
                abi: this.abi,
                method: this.method,
                params: this.params,
            },
            stateInit: args.stateInit,
        });
        return (0, models_1.parseTransaction)(transaction);
    }
    async sendDelayed(args) {
        await this.provider.ensureInitialized();
        const transactions = new utils_1.DelayedTransactions();
        const subscription = await this.provider.subscribe('messageStatusUpdated');
        subscription.on('data', data => {
            if (!data.address.equals(args.from)) {
                return;
            }
            transactions.fillTransaction(data.hash, data.transaction);
        });
        const { message } = await this.provider.rawApi
            .sendMessageDelayed({
            sender: args.from.toString(),
            recipient: this.address.toString(),
            amount: args.amount,
            bounce: args.bounce == null ? true : args.bounce,
            payload: {
                abi: this.abi,
                method: this.method,
                params: this.params,
            },
            stateInit: args.stateInit,
        })
            .catch(e => {
            subscription.unsubscribe().catch(console.error);
            throw e;
        });
        const transaction = transactions
            .waitTransaction(this.address, message.hash)
            .finally(() => subscription.unsubscribe().catch(console.error));
        return {
            messageHash: message.hash,
            expireAt: message.expireAt,
            transaction,
        };
    }
    async sendWithResult(args) {
        await this.provider.ensureInitialized();
        let subscriber = args.subscriber;
        const hasTempSubscriber = subscriber == null;
        if (subscriber == null) {
            subscriber = new this.provider.Subscriber();
        }
        try {
            // Parent transaction from wallet
            let parentTransaction = undefined;
            // Child transaction promise
            let resolveChildTransactionPromise;
            const childTransactionPromise = new Promise(resolve => {
                resolveChildTransactionPromise = tx => resolve(tx);
            });
            // Array for collecting transactions on target before parent transaction promise resolution
            const possibleChildren = [];
            // Subscribe to this account
            subscriber
                .transactions(this.address)
                .flatMap(batch => batch.transactions)
                // Listen only messages from sender
                .filter(item => { var _a; return ((_a = item.inMessage.src) === null || _a === void 0 ? void 0 : _a.equals(args.from)) || false; })
                .on(tx => {
                if (parentTransaction == null) {
                    // If we don't known whether the message was sent just collect all transactions from the sender
                    possibleChildren.push(tx);
                }
                else if (parentTransaction.possibleMessages.findIndex(msg => msg.hash == tx.inMessage.hash) >= 0) {
                    // Resolve promise if transaction was found
                    resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(tx);
                }
            });
            // Send message
            const transaction = await this.send(args);
            // Extract all outgoing messages from the parent transaction to this contract
            const possibleMessages = transaction.outMessages.filter(msg => { var _a; return ((_a = msg.dst) === null || _a === void 0 ? void 0 : _a.equals(this.address)) || false; });
            // Update stream state
            parentTransaction = {
                transaction,
                possibleMessages,
            };
            // Check whether child transaction was already found
            const alreadyReceived = possibleChildren.find(tx => {
                return possibleMessages.findIndex(msg => msg.hash == tx.inMessage.hash) >= 0;
            });
            if (alreadyReceived != null) {
                resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(alreadyReceived);
            }
            const childTransaction = await childTransactionPromise;
            // Parse output
            let output = undefined;
            try {
                const result = await this.provider.rawApi.decodeTransaction({
                    transaction: (0, models_1.serializeTransaction)(childTransaction),
                    abi: this.abi,
                    method: this.method,
                });
                if (result != null) {
                    output = this.functionAbi.outputs != null ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, result.output) : {};
                }
            }
            catch (e) {
                console.error(e);
            }
            // Done
            return {
                parentTransaction: parentTransaction.transaction,
                childTransaction,
                output,
            };
        }
        finally {
            hasTempSubscriber && (await subscriber.unsubscribe());
        }
    }
    async estimateFees(args) {
        await this.provider.ensureInitialized();
        const { fees } = await this.provider.rawApi.estimateFees({
            sender: args.from.toString(),
            recipient: this.address.toString(),
            amount: args.amount,
            payload: {
                abi: this.abi,
                method: this.method,
                params: this.params,
            },
            stateInit: args.stateInit,
        });
        return fees;
    }
    async sendExternal(args) {
        await this.provider.ensureInitialized();
        const method = args.withoutSignature === true
            ? this.provider.rawApi.sendUnsignedExternalMessage
            : this.provider.rawApi.sendExternalMessage;
        const { transaction, output } = await method({
            publicKey: args.publicKey,
            recipient: this.address.toString(),
            stateInit: args.stateInit,
            payload: {
                abi: this.abi,
                method: this.method,
                params: this.params,
            },
            local: args.local,
            executorParams: args.executorParams
                ? {
                    disableSignatureCheck: args.executorParams.disableSignatureCheck,
                    overrideBalance: args.executorParams.overrideBalance,
                }
                : undefined,
        });
        return {
            transaction: (0, models_1.parseTransaction)(transaction),
            output: output != null ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined,
        };
    }
    async sendExternalDelayed(args) {
        await this.provider.ensureInitialized();
        const transactions = new utils_1.DelayedTransactions();
        const subscription = await this.provider.subscribe('messageStatusUpdated');
        subscription.on('data', data => {
            if (!data.address.equals(this.address)) {
                return;
            }
            transactions.fillTransaction(data.hash, data.transaction);
        });
        const { message } = await this.provider.rawApi
            .sendExternalMessageDelayed({
            publicKey: args.publicKey,
            recipient: this.address.toString(),
            stateInit: args.stateInit,
            payload: {
                abi: this.abi,
                method: this.method,
                params: this.params,
            },
        })
            .catch(e => {
            subscription.unsubscribe().catch(console.error);
            throw e;
        });
        const transaction = transactions
            .waitTransaction(this.address, message.hash)
            .finally(() => subscription.unsubscribe().catch(console.error));
        return {
            messageHash: message.hash,
            expireAt: message.expireAt,
            transaction,
        };
    }
    async call(args = {}) {
        await this.provider.ensureInitialized();
        const { output, code } = await this.provider.rawApi.runLocal({
            address: this.address.toString(),
            cachedState: args.cachedState,
            responsible: args.responsible,
            functionCall: {
                abi: this.abi,
                method: this.method,
                params: this.params,
            },
        });
        if (output == null || code != 0) {
            throw new TvmException(code);
        }
        else {
            return (0, models_1.parseTokensObject)(this.functionAbi.outputs, output);
        }
    }
    /**
     * Encodes this method as an external message and
     * executes all transaction phases locally, producing a new state
     */
    async executeExternal(args) {
        await this.provider.ensureInitialized();
        const { transaction, newState, output } = await this.provider.rawApi.executeLocal({
            address: this.address.toString(),
            cachedState: args.cachedState,
            stateInit: args.stateInit,
            payload: {
                abi: this.abi,
                method: this.method,
                params: this.params,
            },
            messageHeader: {
                type: 'external',
                publicKey: args.publicKey,
                withoutSignature: args.withoutSignature,
            },
            executorParams: args.executorParams != null
                ? {
                    disableSignatureCheck: args.executorParams.disableSignatureCheck,
                    overrideBalance: args.executorParams.overrideBalance,
                }
                : undefined,
        });
        return {
            transaction: (0, models_1.parseTransaction)(transaction),
            newState,
            output: output !== undefined ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined,
        };
    }
    /**
     * Encodes this method as an internal message and
     * executes all transaction phases locally, producing a new state
     */
    async executeInternal(args) {
        await this.provider.ensureInitialized();
        const { transaction, newState, output } = await this.provider.rawApi.executeLocal({
            address: this.address.toString(),
            cachedState: args.cachedState,
            stateInit: args.stateInit,
            payload: {
                abi: this.abi,
                method: this.method,
                params: this.params,
            },
            messageHeader: {
                type: 'internal',
                sender: args.sender.toString(),
                amount: args.amount,
                bounce: args.bounce != null ? args.bounce : false,
                bounced: args.bounced,
            },
            executorParams: args.executorParams != null
                ? {
                    disableSignatureCheck: args.executorParams.disableSignatureCheck,
                    overrideBalance: args.executorParams.overrideBalance,
                }
                : undefined,
        });
        return {
            transaction: (0, models_1.parseTransaction)(transaction),
            newState,
            output: output !== undefined ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined,
        };
    }
    async encodeInternal() {
        await this.provider.ensureInitialized();
        const { boc } = await this.provider.rawApi.encodeInternalInput({
            abi: this.abi,
            method: this.method,
            params: this.params,
        });
        return boc;
    }
}
