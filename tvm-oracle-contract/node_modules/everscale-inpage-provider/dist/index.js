"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProviderNotInitializedException = exports.ProviderNotFoundException = exports.ProviderRpcClient = exports.hasEverscaleProvider = exports.LT_COLLATOR = exports.isAddressObject = exports.mergeTransactions = exports.MessageExpiredException = exports.AddressLiteral = exports.Address = exports.Subscriber = void 0;
const models_1 = require("./models");
const utils_1 = require("./utils");
const subscriber = __importStar(require("./stream"));
const contract = __importStar(require("./contract"));
__exportStar(require("./api"), exports);
__exportStar(require("./models"), exports);
__exportStar(require("./contract"), exports);
var stream_1 = require("./stream");
Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function () { return stream_1.Subscriber; } });
var utils_2 = require("./utils");
Object.defineProperty(exports, "Address", { enumerable: true, get: function () { return utils_2.Address; } });
Object.defineProperty(exports, "AddressLiteral", { enumerable: true, get: function () { return utils_2.AddressLiteral; } });
Object.defineProperty(exports, "MessageExpiredException", { enumerable: true, get: function () { return utils_2.MessageExpiredException; } });
Object.defineProperty(exports, "mergeTransactions", { enumerable: true, get: function () { return utils_2.mergeTransactions; } });
Object.defineProperty(exports, "isAddressObject", { enumerable: true, get: function () { return utils_2.isAddressObject; } });
Object.defineProperty(exports, "LT_COLLATOR", { enumerable: true, get: function () { return utils_2.LT_COLLATOR; } });
const isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
let ensurePageLoaded;
if (!isBrowser || document.readyState === 'complete') {
    ensurePageLoaded = Promise.resolve();
}
else {
    ensurePageLoaded = new Promise(resolve => {
        window.addEventListener('load', () => {
            resolve();
        });
    });
}
const getProvider = () => (isBrowser ? window.__ever || window.ton : undefined);
/**
 * @category Provider
 */
async function hasEverscaleProvider() {
    if (!isBrowser) {
        return false;
    }
    await ensurePageLoaded;
    return window.__hasEverscaleProvider === true || window.hasTonProvider === true;
}
exports.hasEverscaleProvider = hasEverscaleProvider;
/**
 * @category Provider
 */
class ProviderRpcClient {
    constructor(properties = {}) {
        this._subscriptions = {
            connected: new Map(),
            disconnected: new Map(),
            transactionsFound: new Map(),
            contractStateChanged: new Map(),
            messageStatusUpdated: new Map(),
            networkChanged: new Map(),
            permissionsChanged: new Map(),
            loggedOut: new Map(),
        };
        this._contractSubscriptions = new Map();
        this._properties = properties;
        const self = this;
        // Create contract proxy type
        class ProviderContract extends contract.Contract {
            constructor(abi, address) {
                super(self, abi, address);
            }
        }
        this.Contract = ProviderContract;
        // Create subscriber proxy type
        class ProviderSubscriber extends subscriber.Subscriber {
            constructor() {
                super(self);
            }
        }
        this.Subscriber = ProviderSubscriber;
        // Wrap provider requests
        this._api = new Proxy({}, {
            get: (_object, method) => (params) => {
                if (this._provider != null) {
                    return this._provider.request({ method, params });
                }
                else {
                    throw new ProviderNotInitializedException();
                }
            },
        });
        if (properties.forceUseFallback === true) {
            this._initializationPromise =
                properties.fallback != null
                    ? properties.fallback().then(provider => {
                        this._provider = provider;
                    })
                    : Promise.resolve();
        }
        else {
            // Initialize provider with injected object by default
            this._provider = getProvider();
            if (this._provider != null) {
                // Provider as already injected
                this._initializationPromise = Promise.resolve();
            }
            else {
                // Wait until page is loaded and initialization complete
                this._initializationPromise = hasEverscaleProvider()
                    .then(hasProvider => new Promise(resolve => {
                    if (!hasProvider) {
                        // Fully loaded page doesn't even contain provider flag
                        return resolve();
                    }
                    // Wait injected provider initialization otherwise
                    this._provider = getProvider();
                    if (this._provider != null) {
                        resolve();
                    }
                    else {
                        const eventName = window.__hasEverscaleProvider === true ? 'ever#initialized' : 'ton#initialized';
                        window.addEventListener(eventName, _ => {
                            this._provider = getProvider();
                            resolve();
                        });
                    }
                }))
                    .then(async () => {
                    if (this._provider == null && properties.fallback != null) {
                        this._provider = await properties.fallback();
                    }
                });
            }
        }
        // Will only register handlers for successfully loaded injected provider
        this._initializationPromise.then(() => {
            if (this._provider != null) {
                this._registerEventHandlers(this._provider);
            }
        });
    }
    /**
     * Checks whether this page has injected Everscale provider or
     * there is a fallback provider.
     */
    async hasProvider() {
        if (this._properties.fallback != null) {
            return true;
        }
        return hasEverscaleProvider();
    }
    /**
     * Waits until provider api will be available. Calls `fallback` if no provider was found
     *
     * @throws ProviderNotFoundException when no provider found
     */
    async ensureInitialized() {
        await this._initializationPromise;
        if (this._provider == null) {
            throw new ProviderNotFoundException();
        }
    }
    /**
     * Whether provider api is ready
     */
    get isInitialized() {
        return this._provider != null;
    }
    /**
     * Raw provider
     */
    get raw() {
        if (this._provider != null) {
            return this._provider;
        }
        else {
            throw new ProviderNotInitializedException();
        }
    }
    /**
     * Raw provider api
     */
    get rawApi() {
        return this._api;
    }
    /**
     * Creates typed contract wrapper.
     *
     * @param abi Readonly object (must be declared with `as const`)
     * @param address Default contract address
     *
     * @deprecated `new ever.Contract(abi, address)` should be used instead
     */
    createContract(abi, address) {
        return new this.Contract(abi, address);
    }
    /**
     * Creates subscriptions group
     *
     * @deprecated `new ever.Subscriber()` should be used instead
     */
    createSubscriber() {
        return new this.Subscriber();
    }
    /**
     * Requests new permissions for current origin.
     * Shows an approval window to the user.
     * Will overwrite already existing permissions
     *
     * ---
     * Required permissions: none
     */
    async requestPermissions(args) {
        await this.ensureInitialized();
        const result = await this._api.requestPermissions({
            permissions: args.permissions,
        });
        return (0, models_1.parsePermissions)(result);
    }
    /**
     * Updates `accountInteraction` permission value
     *
     * ---
     * Requires permissions: `accountInteraction`
     */
    async changeAccount() {
        await this.ensureInitialized();
        await this._api.changeAccount();
    }
    /**
     * Removes all permissions for current origin and stops all subscriptions
     */
    async disconnect() {
        await this.ensureInitialized();
        await this._api.disconnect();
    }
    async subscribe(eventName, params) {
        class SubscriptionImpl {
            constructor(_subscribe, _unsubscribe) {
                this._subscribe = _subscribe;
                this._unsubscribe = _unsubscribe;
                this._listeners = {
                    data: [],
                    subscribed: [],
                    unsubscribed: [],
                };
                this._subscribed = false;
                this.subscribe = async () => {
                    if (this._subscribed) {
                        return;
                    }
                    this._subscribed = true;
                    await this._subscribe(this);
                    for (const handler of this._listeners['subscribed']) {
                        handler();
                    }
                };
                this.unsubscribe = async () => {
                    if (!this._subscribed) {
                        return;
                    }
                    this._subscribed = false;
                    await this._unsubscribe();
                    for (const handler of this._listeners['unsubscribed']) {
                        handler();
                    }
                };
            }
            on(eventName, listener) {
                this._listeners[eventName].push(listener);
                return this;
            }
            notify(data) {
                for (const handler of this._listeners['data']) {
                    handler(data);
                }
            }
        }
        const existingSubscriptions = this._subscriptions[eventName];
        const id = (0, utils_1.getUniqueId)();
        switch (eventName) {
            case 'connected':
            case 'disconnected':
            case 'messageStatusUpdated':
            case 'networkChanged':
            case 'permissionsChanged':
            case 'loggedOut': {
                const subscription = new SubscriptionImpl(async (subscription) => {
                    if (existingSubscriptions.has(id)) {
                        return;
                    }
                    existingSubscriptions.set(id, data => {
                        subscription.notify(data);
                    });
                }, async () => {
                    existingSubscriptions.delete(id);
                });
                await subscription.subscribe();
                return subscription;
            }
            case 'transactionsFound':
            case 'contractStateChanged': {
                if (params == null) {
                    throw new Error('Address must be specified for the subscription');
                }
                await this.ensureInitialized();
                const address = params.address.toString();
                const subscription = new SubscriptionImpl(async (subscription) => {
                    if (existingSubscriptions.has(id)) {
                        return;
                    }
                    existingSubscriptions.set(id, ((data) => {
                        if (data.address.toString() === address) {
                            subscription.notify(data);
                        }
                    }));
                    let contractSubscriptions = this._contractSubscriptions.get(address);
                    if (contractSubscriptions == null) {
                        contractSubscriptions = new Map();
                        this._contractSubscriptions.set(address, contractSubscriptions);
                    }
                    const subscriptionState = {
                        state: eventName === 'contractStateChanged',
                        transactions: eventName === 'transactionsFound',
                    };
                    contractSubscriptions.set(id, subscriptionState);
                    const { total, withoutExcluded } = foldSubscriptions(contractSubscriptions.values(), subscriptionState);
                    try {
                        if (total.transactions !== withoutExcluded.transactions || total.state !== withoutExcluded.state) {
                            await this.rawApi.subscribe({ address, subscriptions: total });
                        }
                    }
                    catch (e) {
                        existingSubscriptions.delete(id);
                        contractSubscriptions.delete(id);
                        throw e;
                    }
                }, async () => {
                    existingSubscriptions.delete(id);
                    const contractSubscriptions = this._contractSubscriptions.get(address);
                    if (contractSubscriptions == null) {
                        return;
                    }
                    const updates = contractSubscriptions.get(id);
                    const { total, withoutExcluded } = foldSubscriptions(contractSubscriptions.values(), updates);
                    contractSubscriptions.delete(id);
                    if (!withoutExcluded.transactions && !withoutExcluded.state) {
                        await this.rawApi.unsubscribe({ address });
                    }
                    else if (total.transactions !== withoutExcluded.transactions || total.state !== withoutExcluded.state) {
                        await this.rawApi.subscribe({ address, subscriptions: withoutExcluded });
                    }
                });
                await subscription.subscribe();
                return subscription;
            }
            default: {
                throw new Error(`Unknown event ${eventName}`);
            }
        }
    }
    /**
     * Returns provider api state
     *
     * ---
     * Required permissions: none
     */
    async getProviderState() {
        await this.ensureInitialized();
        const state = await this._api.getProviderState();
        return {
            ...state,
            permissions: (0, models_1.parsePermissions)(state.permissions),
        };
    }
    /**
     * Requests contract balance
     *
     * ---
     * Required permissions: `basic`
     */
    async getBalance(address) {
        const { state } = await this.getFullContractState({
            address,
        });
        return state == null ? '0' : state === null || state === void 0 ? void 0 : state.balance;
    }
    /**
     * Requests contract data
     *
     * ---
     * Required permissions: `basic`
     */
    async getFullContractState(args) {
        await this.ensureInitialized();
        return (await this._api.getFullContractState({
            address: args.address.toString(),
        }));
    }
    /**
     * Requests accounts with specified code hash
     *
     * ---
     * Required permissions: `basic`
     */
    async getAccountsByCodeHash(args) {
        await this.ensureInitialized();
        const { accounts, continuation } = await this._api.getAccountsByCodeHash({
            ...args,
        });
        return {
            accounts: accounts.map(address => new utils_1.Address(address)),
            continuation,
        };
    }
    /**
     * Requests contract transactions
     *
     * ---
     * Required permissions: `basic`
     */
    async getTransactions(args) {
        await this.ensureInitialized();
        const { transactions, continuation, info } = await this._api.getTransactions({
            ...args,
            address: args.address.toString(),
        });
        return {
            transactions: transactions.map(models_1.parseTransaction),
            continuation,
            info,
        };
    }
    /**
     * Searches transaction by hash
     *
     * ---
     * Required permissions: `basic`
     */
    async getTransaction(args) {
        await this.ensureInitialized();
        const { transaction } = await this._api.getTransaction({
            ...args,
        });
        return {
            transaction: transaction ? (0, models_1.parseTransaction)(transaction) : undefined,
        };
    }
    /**
     * Computes contract address from code and init params
     *
     * ---
     * Required permissions: `basic`
     */
    async getExpectedAddress(abi, args) {
        const { address } = await this.getStateInit(abi, args);
        return address;
    }
    /**
     * Computes contract address and state from code and init params
     *
     * ---
     * Required permissions: `basic`
     */
    async getStateInit(abi, args) {
        await this.ensureInitialized();
        const { address, stateInit, hash } = await this._api.getExpectedAddress({
            abi: JSON.stringify(abi),
            ...args,
            initParams: (0, models_1.serializeTokensObject)(args.initParams),
        });
        return {
            address: new utils_1.Address(address),
            stateInit,
            hash,
        };
    }
    /**
     * Decodes initial contract data using the specified ABI
     *
     * ---
     * Required permissions: `basic`
     */
    async unpackInitData(abi, data) {
        await this.ensureInitialized();
        const { publicKey, initParams } = await this._api.unpackInitData({
            abi: JSON.stringify(abi),
            data,
        });
        return {
            publicKey,
            initParams: (0, models_1.parsePartialTokensObject)(abi.data, initParams),
        };
    }
    /**
     * Computes hash of base64 encoded BOC
     *
     * ---
     * Required permissions: `basic`
     */
    async getBocHash(boc) {
        await this.ensureInitialized();
        return await this._api
            .getBocHash({
            boc,
        })
            .then(({ hash }) => hash);
    }
    /**
     * Creates base64 encoded BOC
     *
     * ---
     * Required permissions: `basic`
     */
    async packIntoCell(args) {
        await this.ensureInitialized();
        return (await this._api.packIntoCell({
            abiVersion: args.abiVersion,
            structure: args.structure,
            data: (0, models_1.serializeTokensObject)(args.data),
        }));
    }
    /**
     * Decodes base64 encoded BOC
     *
     * ---
     * Required permissions: `basic`
     */
    async unpackFromCell(args) {
        await this.ensureInitialized();
        const { data } = await this._api.unpackFromCell({
            ...args,
            structure: args.structure,
        });
        return {
            data: (0, models_1.parseTokensObject)(args.structure, data),
        };
    }
    /**
     * Extracts public key from raw account state
     *
     * **NOTE:** can only be used on contracts which are deployed and has `pubkey` header
     *
     * ---
     * Required permissions: `basic`
     */
    async extractPublicKey(boc) {
        await this.ensureInitialized();
        const { publicKey } = await this._api.extractPublicKey({
            boc,
        });
        return publicKey;
    }
    /**
     * Converts base64 encoded contract code into tvc with default init data
     *
     * ---
     * Required permissions: `basic`
     */
    async codeToTvc(code) {
        await this.ensureInitialized();
        const { tvc } = await this._api.codeToTvc({
            code,
        });
        return tvc;
    }
    /**
     * Merges code and data into state init
     *
     * ---
     * Required permissions: `basic`
     */
    async mergeTvc(args) {
        await this.ensureInitialized();
        return await this._api.mergeTvc(args);
    }
    /**
     * Splits base64 encoded state init into code and data
     *
     * ---
     * Required permissions: `basic`
     */
    async splitTvc(tvc) {
        await this.ensureInitialized();
        return await this._api.splitTvc({
            tvc,
        });
    }
    /**
     * Merges code and data into state init
     *
     * ---
     * Required permissions: `basic`
     */
    async setCodeSalt(args) {
        let salt;
        if (typeof args.salt === 'string') {
            await this.ensureInitialized();
            salt = args.salt;
        }
        else {
            const { boc } = await this.packIntoCell(args.salt);
            salt = boc;
        }
        return await this._api.setCodeSalt({ code: args.code, salt });
    }
    /**
     * Retrieves salt from code. Returns undefined if code doesn't contain salt
     *
     * ---
     * Required permissions: `basic`
     */
    async getCodeSalt(args) {
        await this.ensureInitialized();
        const { salt } = await this.rawApi.getCodeSalt({
            code: args.code,
        });
        return salt;
    }
    /**
     * Adds asset to the selected account
     *
     * ---
     * Requires permissions: `accountInteraction`
     */
    async addAsset(args) {
        await this.ensureInitialized();
        let params;
        switch (args.type) {
            case 'tip3_token': {
                params = {
                    rootContract: args.params.rootContract.toString(),
                };
                break;
            }
            default:
                throw new Error('Unknown asset type');
        }
        return await this._api.addAsset({
            account: args.account.toString(),
            type: args.type,
            params,
        });
    }
    async verifySignature(args) {
        await this.ensureInitialized();
        return await this._api.verifySignature(args);
    }
    /**
     * Signs arbitrary data.
     *
     * NOTE: hashes data before signing. Use `signDataRaw` to sign without hash.
     *
     * ---
     * Requires permissions: `accountInteraction`
     */
    async signData(args) {
        await this.ensureInitialized();
        return await this._api.signData(args);
    }
    /**
     * Signs arbitrary data without hashing it
     *
     * ---
     * Requires permissions: `accountInteraction`
     */
    async signDataRaw(args) {
        await this.ensureInitialized();
        return await this._api.signDataRaw(args);
    }
    /**
     * Encrypts arbitrary data with specified algorithm for each specified recipient
     *
     * ---
     * Requires permissions: `accountInteraction`
     */
    async encryptData(args) {
        await this.ensureInitialized();
        const { encryptedData } = await this._api.encryptData(args);
        return encryptedData;
    }
    /**
     * Decrypts encrypted data. Returns base64 encoded data
     *
     * ---
     * Requires permissions: `accountInteraction`
     */
    async decryptData(encryptedData) {
        await this.ensureInitialized();
        const { data } = await this._api.decryptData({ encryptedData });
        return data;
    }
    /**
     * Sends an internal message from the user account.
     * Shows an approval window to the user.
     *
     * ---
     * Required permissions: `accountInteraction`
     */
    async sendMessage(args) {
        await this.ensureInitialized();
        const { transaction } = await this._api.sendMessage({
            sender: args.sender.toString(),
            recipient: args.recipient.toString(),
            amount: args.amount,
            bounce: args.bounce,
            payload: args.payload
                ? {
                    abi: args.payload.abi,
                    method: args.payload.method,
                    params: (0, models_1.serializeTokensObject)(args.payload.params),
                }
                : undefined,
            stateInit: args.stateInit,
        });
        return {
            transaction: (0, models_1.parseTransaction)(transaction),
        };
    }
    /**
     * Sends an internal message from the user account without waiting for the transaction.
     * Shows an approval window to the user.
     *
     * @see messageStatusUpdated
     *
     * ---
     * Required permissions: `accountInteraction`
     */
    async sendMessageDelayed(args) {
        await this.ensureInitialized();
        const transactions = new utils_1.DelayedTransactions();
        const subscription = await this.subscribe('messageStatusUpdated');
        subscription.on('data', data => {
            if (!data.address.equals(args.sender)) {
                return;
            }
            transactions.fillTransaction(data.hash, data.transaction);
        });
        const { message } = await this._api
            .sendMessageDelayed({
            sender: args.sender.toString(),
            recipient: args.recipient.toString(),
            amount: args.amount,
            bounce: args.bounce,
            payload: args.payload
                ? {
                    abi: args.payload.abi,
                    method: args.payload.method,
                    params: (0, models_1.serializeTokensObject)(args.payload.params),
                }
                : undefined,
            stateInit: args.stateInit,
        })
            .catch(e => {
            subscription.unsubscribe().catch(console.error);
            throw e;
        });
        const transaction = transactions
            .waitTransaction(args.sender, message.hash)
            .finally(() => subscription.unsubscribe().catch(console.error));
        return {
            messageHash: message.hash,
            expireAt: message.expireAt,
            transaction,
        };
    }
    _registerEventHandlers(provider) {
        const knownEvents = {
            connected: data => data,
            disconnected: data => data,
            transactionsFound: data => ({
                address: new utils_1.Address(data.address),
                transactions: data.transactions.map(models_1.parseTransaction),
                info: data.info,
            }),
            contractStateChanged: data => ({
                address: new utils_1.Address(data.address),
                state: data.state,
            }),
            messageStatusUpdated: data => ({
                address: new utils_1.Address(data.address),
                hash: data.hash,
                transaction: data.transaction != null ? (0, models_1.parseTransaction)(data.transaction) : undefined,
            }),
            networkChanged: data => data,
            permissionsChanged: data => ({
                permissions: (0, models_1.parsePermissions)(data.permissions),
            }),
            loggedOut: data => data,
        };
        for (const [eventName, extractor] of Object.entries(knownEvents)) {
            provider.addListener(eventName, data => {
                const handlers = this._subscriptions[eventName];
                const parsed = extractor(data);
                for (const handler of handlers.values()) {
                    handler(parsed);
                }
            });
        }
    }
}
exports.ProviderRpcClient = ProviderRpcClient;
/**
 * @category Provider
 */
class ProviderNotFoundException extends Error {
    constructor() {
        super('Everscale provider was not found');
    }
}
exports.ProviderNotFoundException = ProviderNotFoundException;
/**
 * @category Provider
 */
class ProviderNotInitializedException extends Error {
    constructor() {
        super('Everscale provider was not initialized yet');
    }
}
exports.ProviderNotInitializedException = ProviderNotInitializedException;
function foldSubscriptions(subscriptions, except) {
    const total = { state: false, transactions: false };
    const withoutExcluded = Object.assign({}, total);
    for (const item of subscriptions) {
        if (withoutExcluded.transactions && withoutExcluded.state) {
            break;
        }
        total.state || (total.state = item.state);
        total.transactions || (total.transactions = item.transactions);
        if (item !== except) {
            withoutExcluded.state || (withoutExcluded.state = item.state);
            withoutExcluded.transactions || (withoutExcluded.transactions = item.transactions);
        }
    }
    return { total, withoutExcluded };
}
