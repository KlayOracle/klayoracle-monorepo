import { ProviderEventData } from './api';
import { Address } from './utils';
import { Transaction, TransactionWithAccount } from './models';
import { ProviderRpcClient } from './index';
/**
 * @category Stream
 */
export declare class Subscriber {
    private readonly provider;
    private readonly subscriptions;
    private readonly scanners;
    constructor(provider: ProviderRpcClient);
    /**
     * Returns a stream of new transactions
     */
    transactions(address: Address): IdentityStream<ProviderEventData<'transactionsFound'>>;
    /**
     * Returns a finite stream of child transactions
     * @param transaction - root transaction
     */
    trace(transaction: Transaction): IdentityStream<TransactionWithAccount, true>;
    /**
     * Returns a stream of old transactions
     */
    oldTransactions(address: Address, filter?: {
        fromLt?: string;
        fromUtime?: number;
    }): IdentityStream<ProviderEventData<'transactionsFound'>, true>;
    states(address: Address): IdentityStream<ProviderEventData<'contractStateChanged'>>;
    unsubscribe: () => Promise<void>;
    private _unsubscribe;
    private _addSubscription;
}
/**
 * @category Stream
 */
export declare type BothFinite<F extends boolean, F1 extends boolean> = F extends true ? F1 extends true ? true : false : false;
/**
 * @category Stream
 */
export declare type IdentityStream<T, F extends boolean = false> = Stream<T, T, F>;
/**
 * @category Stream
 */
export interface Stream<P, T, F extends boolean = false> {
    readonly makeProducer: (onData: (data: P) => Promise<boolean>, onEnd: (eof: boolean) => void) => Promise<void>;
    readonly stopProducer: () => void;
    readonly isFinite: F;
    /**
     * Waits until contract subscription is ready and then returns a promise with the result
     */
    delayed<R>(f: (stream: Delayed<P, T, F>) => DelayedPromise<R>): Promise<() => R>;
    /**
     * Waits for the first element or the end of the stream
     */
    first(): Promise<F extends true ? T | undefined : T>;
    /**
     * Folds every element into an accumulator by applying an operation, returning the final result
     */
    fold: F extends true ? <B>(init: B, f: (init: B, item: T) => (Promise<B> | B)) => Promise<B> : never;
    /**
     * Waits until the end of the stream
     */
    finished: F extends true ? () => Promise<void> : never;
    /**
     * Executes handler on each item
     */
    on(handler: (item: T) => (Promise<void> | void)): void;
    /**
     * Merges two streams
     */
    merge<F1 extends boolean>(other: Stream<P, T, F1>): Stream<P, T, BothFinite<F, F1>>;
    /**
     * Creates a stream which gives the current iteration count as well as the value
     */
    enumerate(): Stream<P, {
        index: number;
        item: T;
    }, F>;
    /**
     * Alias for the `.map((item) => { f(item); return item; })`
     */
    tap(handler: (item: T) => (Promise<void> | void)): Stream<P, T, F>;
    /**
     * Skip elements where `f(item) == false`
     */
    filter(f: (item: T) => (Promise<boolean> | boolean)): Stream<P, T, F>;
    /**
     * Modifies items and skip all `undefined`
     */
    filterMap<U>(f: (item: T) => (Promise<(U | undefined)> | (U | undefined))): Stream<P, U, F>;
    /**
     * Modifies items
     */
    map<U>(f: (item: T) => (Promise<U> | U)): Stream<P, U, F>;
    /**
     * Creates an iterator that flattens nested structure
     */
    flatMap<U>(f: (item: T) => (Promise<U[]> | U[])): Stream<P, U, F>;
    /**
     * Creates an iterator that skips the first n elements
     */
    skip(n: number): Stream<P, T, F>;
    /**
     * Creates an iterator that skips elements based on a predicate
     */
    skipWhile(f: (item: T) => (Promise<boolean> | boolean)): Stream<P, T, F>;
    /**
     * Creates an iterator that yields the first n elements, or fewer if the underlying iterator ends sooner
     */
    take(n: number): Stream<P, T, true>;
    /**
     * Creates an iterator that yields elements based on a predicate
     */
    takeWhile(f: (item: T) => (Promise<boolean> | boolean)): Stream<P, T, true>;
    /**
     * Creates an iterator that yields mapped elements based on a predicate until first `undefined` is found
     */
    takeWhileMap<U>(f: (item: T) => (Promise<(U | undefined)> | (U | undefined))): Stream<P, U, true>;
}
/**
 * @category Stream
 */
export declare type Delayed<P, T, F extends boolean> = {
    first: MakeDelayedPromise<Stream<P, T, F>['first']>;
    on: MakeDelayedPromise<Stream<P, T, F>['on']>;
} & (F extends true ? {
    fold: MakeDelayedPromise<Stream<P, T, F>['fold']>;
    finished: MakeDelayedPromise<Stream<P, T, F>['finished']>;
} : {});
/**
 * @category Stream
 */
export declare type MakeDelayedPromise<F> = F extends (...args: infer Args) => infer R ? (...args: Args) => DelayedPromise<R> : never;
/**
 * @category Stream
 */
export declare type DelayedPromise<T> = {
    subscribed: Promise<void>;
    result: T;
};
