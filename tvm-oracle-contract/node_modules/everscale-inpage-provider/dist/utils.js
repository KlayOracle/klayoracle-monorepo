"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUniqueId = exports.mergeTransactions = exports.LT_COLLATOR = exports.Semaphore = exports.DelayedTransactions = exports.MessageExpiredException = exports.AddressLiteral = exports.isAddressObject = exports.Address = void 0;
/**
 * @category Utils
 */
class Address {
    constructor(address) {
        this.equals = (other) => this._equals(other);
        this._address = address;
    }
    toString() {
        return this._address;
    }
    toJSON() {
        return this._address;
    }
    _equals(other) {
        if (typeof other === 'string') {
            return this._address === other;
        }
        else {
            return this._address === (other === null || other === void 0 ? void 0 : other._address);
        }
    }
}
exports.Address = Address;
/**
 * Check whether the provider object is instance of `Address`,
 * handling the case of duplicated dependencies.
 */
function isAddressObject(address) {
    return (address != null &&
        (address instanceof Address ||
            Object.getPrototypeOf(address).constructor.name === Address.prototype.constructor.name));
}
exports.isAddressObject = isAddressObject;
/**
 * @category Utils
 */
class AddressLiteral extends Address {
    constructor(address) {
        super(address);
    }
}
exports.AddressLiteral = AddressLiteral;
/**
 * @category Utils
 */
class MessageExpiredException extends Error {
    constructor(address, hash) {
        super('Message expired');
        this.address = address;
        this.hash = hash;
    }
}
exports.MessageExpiredException = MessageExpiredException;
class DelayedTransactions {
    constructor() {
        this.transactions = new Map();
    }
    async waitTransaction(address, hash) {
        var _a;
        let transaction = (_a = this.transactions.get(hash)) === null || _a === void 0 ? void 0 : _a.promise;
        if (transaction == null) {
            let resolve;
            let reject;
            transaction = new Promise((promiseResolve, promiseReject) => {
                resolve = (tx) => promiseResolve(tx);
                reject = () => promiseReject();
            });
            this.transactions.set(hash, {
                promise: transaction,
                resolve: resolve,
                reject: reject,
            });
        }
        const tx = await transaction;
        if (tx == null) {
            throw new MessageExpiredException(address, hash);
        }
        return tx;
    }
    fillTransaction(hash, transaction) {
        const pendingTransaction = this.transactions.get(hash);
        if (pendingTransaction != null) {
            pendingTransaction.resolve(transaction);
        }
        else {
            this.transactions.set(hash, {
                promise: Promise.resolve(transaction),
                resolve: () => {
                },
                reject: () => {
                },
            });
        }
    }
}
exports.DelayedTransactions = DelayedTransactions;
/**
 * @category Utils
 */
class Semaphore {
    constructor(count) {
        this.tasks = [];
        this.sched = () => {
            var _a;
            if (this.count > 0 && this.tasks.length > 0) {
                this.count--;
                (_a = this.tasks.shift()) === null || _a === void 0 ? void 0 : _a();
            }
        };
        this.count = count;
    }
    acquire() {
        return new Promise((res, _rej) => {
            this.tasks.push(() => {
                let released = false;
                res(() => {
                    if (!released) {
                        released = true;
                        this.count++;
                        this.sched();
                    }
                });
            });
            nextTick(this.sched);
        });
    }
    releaseAll() {
        var _a;
        while (this.tasks.length > 0) {
            (_a = this.tasks.shift()) === null || _a === void 0 ? void 0 : _a();
        }
    }
}
exports.Semaphore = Semaphore;
function byObserver(Observer) {
    const node = document.createTextNode('');
    let queue, currentQueue, bit = 0, i = 0;
    new Observer(function () {
        let callback;
        if (!queue) {
            if (!currentQueue)
                return;
            queue = currentQueue;
        }
        else if (currentQueue) {
            queue = currentQueue.slice(i).concat(queue);
        }
        currentQueue = queue;
        queue = null;
        i = 0;
        if (typeof currentQueue === 'function') {
            callback = currentQueue;
            currentQueue = null;
            callback();
            return;
        }
        node.data = (bit = ++bit % 2);
        while (i < currentQueue.length) {
            callback = currentQueue[i];
            i++;
            if (i === currentQueue.length)
                currentQueue = null;
            callback();
        }
    }).observe(node, { characterData: true });
    return function (fn) {
        if (queue) {
            if (typeof queue === 'function')
                queue = [queue, fn];
            else
                queue.push(fn);
            return;
        }
        queue = fn;
        node.data = (bit = ++bit % 2);
    };
}
const nextTick = (function () {
    // queueMicrotask
    if (typeof queueMicrotask === 'function') {
        return queueMicrotask;
    }
    // MutationObserver
    if ((typeof document === 'object') && document) {
        if (typeof MutationObserver === 'function')
            return byObserver(MutationObserver);
        if (typeof window.WebKitMutationObserver === 'function')
            return byObserver(window.WebKitMutationObserver);
    }
    /* @ts-ignore */
    if (typeof setImmediate === 'function') {
        /* @ts-ignore */
        return setImmediate;
    }
    if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {
        return function (cb) {
            setTimeout(cb, 0);
        };
    }
    throw new Error('No `nextTick` implementation found');
}());
/**
 * @category Utils
 */
exports.LT_COLLATOR = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });
/**
 * Modifies knownTransactions array, merging it with new transactions.
 * All arrays are assumed to be sorted by descending logical time.
 *
 * > Note! This method does not remove duplicates.
 *
 * @param knownTransactions
 * @param newTransactions
 * @param info
 *
 * @category Utils
 */
function mergeTransactions(knownTransactions, newTransactions, info) {
    if (info.batchType === 'old') {
        knownTransactions.push(...newTransactions);
        return knownTransactions;
    }
    if (knownTransactions.length === 0) {
        knownTransactions.push(...newTransactions);
        return knownTransactions;
    }
    // Example:
    // known lts: [N, N-1, N-2, N-3, (!) N-10,...]
    // new lts: [N-4, N-5]
    // batch info: { minLt: N-5, maxLt: N-4, batchType: 'new' }
    // 1. Skip indices until known transaction lt is greater than the biggest in the batch
    let i = 0;
    while (i < knownTransactions.length &&
        exports.LT_COLLATOR.compare(knownTransactions[i].id.lt, info.maxLt) >= 0) {
        ++i;
    }
    // 2. Insert new transactions
    knownTransactions.splice(i, 0, ...newTransactions);
    return knownTransactions;
}
exports.mergeTransactions = mergeTransactions;
const MAX = 4294967295;
let idCounter = Math.floor(Math.random() * MAX);
function getUniqueId() {
    idCounter = (idCounter + 1) % MAX;
    return idCounter;
}
exports.getUniqueId = getUniqueId;
