"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HighloadWalletV2 = void 0;
const everscale_inpage_provider_1 = require("everscale-inpage-provider");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const core_1 = __importDefault(require("../../core"));
const utils_1 = require("../utils");
const { ensureNekotonLoaded, nekoton } = core_1.default;
/**
 * @category AccountsStorage
 */
class HighloadWalletV2 {
    static async computeAddress(args) {
        // TODO: Somehow propagate init params
        await ensureNekotonLoaded();
        const publicKey = args.publicKey instanceof bignumber_js_1.default ? args.publicKey : new bignumber_js_1.default(`0x${args.publicKey}`);
        const hash = makeStateInit(publicKey).hash;
        return new everscale_inpage_provider_1.Address(`${args.workchain != null ? args.workchain : 0}:${hash}`);
    }
    static async fromPubkey(args) {
        const publicKey = new bignumber_js_1.default(`0x${args.publicKey}`);
        const address = await HighloadWalletV2.computeAddress({ publicKey, workchain: args.workchain });
        const result = new HighloadWalletV2(address);
        result.publicKey = publicKey;
        return result;
    }
    constructor(address) {
        this.address = (0, utils_1.convertToAddressObject)(address);
    }
    async fetchPublicKey(ctx) {
        let publicKey = this.publicKey;
        if (publicKey == null) {
            publicKey = this.publicKey = await ctx
                .fetchPublicKey(this.address)
                .then(publicKey => new bignumber_js_1.default(`0x${publicKey}`));
        }
        return publicKey.toString(16).padStart(64, '0');
    }
    async prepareMessage(args, ctx) {
        const { publicKey, stateInit } = await this.fetchState(ctx);
        const signer = await ctx.getSigner(publicKey);
        const expireAt = ctx.nowSec + args.timeout;
        const attachedPayload = args.payload ? ctx.encodeInternalInput(args.payload) : undefined;
        const internalMessage = ctx.encodeInternalMessage({
            dst: args.recipient,
            bounce: args.bounce,
            stateInit: args.stateInit,
            body: attachedPayload,
            amount: args.amount,
        });
        const params = {
            messages: [
                [
                    0,
                    {
                        flags: 3,
                        message: internalMessage,
                    },
                ],
            ],
        };
        const { boc: messages, hash: messagesHash } = ctx.packIntoCell({ structure: MESSAGES_STRUCTURE, data: params });
        params.walletId = WALLET_ID;
        params.expireAt = expireAt;
        params.messagesHash = `0x${messagesHash.slice(-8)}`;
        const hash = ctx.packIntoCell({ structure: UNSIGNED_TRANSFER_STRUCTURE, data: params }).hash;
        const signature = await signer.sign(hash, args.signatureId);
        const { signatureParts } = ctx.extendSignature(signature);
        params.signatureHigh = signatureParts.high;
        params.signatureLow = signatureParts.low;
        const signedPayload = ctx.packIntoCell({ structure: SIGNED_TRANSFER_STRUCTURE, data: params }).boc;
        return ctx.createRawExternalMessage({
            address: this.address.toString(),
            body: signedPayload,
            stateInit,
            expireAt,
        });
    }
    async fetchState(ctx) {
        let stateInit = undefined;
        let publicKey;
        const state = await ctx.getFullContractState(this.address);
        if (state == null || !state.isDeployed) {
            if (this.publicKey == null) {
                throw new Error('Contract not deployed and public key was not specified');
            }
            stateInit = makeStateInit(this.publicKey).boc;
            publicKey = this.publicKey;
        }
        else if (this.publicKey == null) {
            const data = ctx.extractContractData(state.boc);
            if (data == null) {
                throw new Error('Failed to extract contract data');
            }
            publicKey = parseInitData(ctx, data).publicKey;
        }
        else {
            publicKey = this.publicKey;
        }
        if (this.publicKey == null) {
            this.publicKey = publicKey;
        }
        return {
            publicKey: publicKey.toString(16).padStart(64, '0'),
            stateInit,
        };
    }
}
exports.HighloadWalletV2 = HighloadWalletV2;
const parseInitData = (ctx, boc) => {
    const parsed = ctx.unpackFromCell({ structure: DATA_STRUCTURE, boc, allowPartial: true });
    if (typeof parsed !== 'object' || typeof parsed['publicKey'] !== 'string') {
        throw new Error('Invalid contract data');
    }
    return {
        publicKey: new bignumber_js_1.default(parsed.publicKey),
    };
};
const makeStateInit = (publicKey) => {
    const data = nekoton.packIntoCell(DATA_STRUCTURE, {
        walletId: WALLET_ID,
        lastCleaned: 0,
        publicKey: publicKey.toFixed(0),
        queries: false,
    }).boc;
    return nekoton.mergeTvc(HIGHLOAD_WALLET_V2_CODE, data);
};
const MESSAGES_STRUCTURE = [
    {
        name: 'messages',
        type: 'map(uint16,tuple)',
        components: [
            { name: 'flags', type: 'uint8' },
            { name: 'message', type: 'cell' },
        ],
    },
];
const UNSIGNED_TRANSFER_STRUCTURE = [
    { name: 'walletId', type: 'uint32' },
    { name: 'expireAt', type: 'uint32' },
    { name: 'messagesHash', type: 'uint32' },
    ...MESSAGES_STRUCTURE,
];
const SIGNED_TRANSFER_STRUCTURE = [
    { name: 'signatureHigh', type: 'uint256' },
    { name: 'signatureLow', type: 'uint256' },
    ...UNSIGNED_TRANSFER_STRUCTURE,
];
const DATA_STRUCTURE = [
    { name: 'walletId', type: 'uint32' },
    { name: 'lastCleaned', type: 'uint64' },
    { name: 'publicKey', type: 'uint256' },
    { name: 'queries', type: 'bool' },
];
const HIGHLOAD_WALLET_V2_CODE = 'te6ccgEBCQEA5QABFP8A9KQT9LzyyAsBAgEgBAIB6vKDCNcYINMf0z/4I6ofUyC58mPtRNDTH9M/0//0BNFTYIBA9A5voTHyYFFzuvKiB/kBVBCH+RDyowL0BNH4AH+OFiGAEPR4b6UgmALTB9QwAfsAkTLiAbPmW4MlochANIBA9EOK5jHIEssfE8s/y//0AMntVAMANCCAQPSWb6UyURCUMFMDud4gkzM2AZIyMOKzAgFICAUCASAHBgBBvl+XaiaGmPmOmf6f+Y+gJoqRBAIHoHN9CYyS2/yV3R8UABe9nOdqJoaa+Y64X/wABNAw';
const WALLET_ID = 0;
