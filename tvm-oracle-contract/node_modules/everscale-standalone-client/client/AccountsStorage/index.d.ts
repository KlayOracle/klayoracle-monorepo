import type * as ever from 'everscale-inpage-provider';
import { AbiVersion, Address } from 'everscale-inpage-provider';
import type * as nt from 'nekoton-wasm';
import { Keystore, Signer } from '../keystore';
import { ConnectionController } from '../ConnectionController';
export { GiverAccount } from './Giver';
export { GenericAccount, MsigAccount } from './Generic';
export { WalletV3Account } from './WalletV3';
export { HighloadWalletV2 } from './HighloadWalletV2';
export { EverWalletAccount } from './EverWallet';
/**
 * @category AccountsStorage
 */
export interface AccountsStorage {
    /**
     * Selected default account
     */
    defaultAccount: Address | undefined;
    /**
     * Returns account for given address
     * @param address: account address
     */
    getAccount(address: string | Address): Promise<Account | undefined>;
}
/**
 * @category AccountsStorage
 */
export interface Account {
    /**
     * Account contract address
     */
    readonly address: Address;
    /**
     * Fetch contract public key
     */
    fetchPublicKey(ctx: AccountsStorageContext): Promise<string>;
    /**
     * Prepares and signs an external message to this account
     *
     * @param args
     * @param ctx
     */
    prepareMessage(args: PrepareMessageParams, ctx: AccountsStorageContext): Promise<nt.SignedMessage>;
}
/**
 * @category AccountsStorage
 */
export type PrepareMessageParams = {
    /**
     * Message destination address
     */
    recipient: string;
    /**
     * Optional base64 encoded `.tvc` file.
     *
     * NOTE: Not guaranteed to be supported
     */
    stateInit?: string;
    /**
     * Amount of nano EVER to send
     */
    amount: string;
    /**
     * Whether to bounce message back on error
     */
    bounce: boolean;
    /**
     * Optional function call
     */
    payload?: ever.FunctionCall<string>;
    /**
     * External message timeout
     */
    timeout: number;
    /**
     * Signature id for the current network
     */
    signatureId?: number;
};
/**
 * @category AccountsStorage
 */
export declare class AccountsStorageContext {
    private readonly clock;
    private readonly connectionController;
    private readonly nekoton;
    private readonly keystore?;
    constructor(clock: nt.ClockWithOffset, connectionController: ConnectionController, nekoton: typeof nt, keystore?: Keystore | undefined);
    getSigner(publicKey: string): Promise<Signer>;
    get nowMs(): number;
    get nowSec(): number;
    fetchPublicKey(address: string | Address): Promise<string>;
    getFullContractState(address: string | Address): Promise<nt.FullContractState | undefined>;
    extractContractData(boc: string): string | undefined;
    packIntoCell(args: {
        structure: nt.AbiParam[];
        data: nt.TokensObject;
        abiVersion?: AbiVersion;
    }): {
        boc: string;
        hash: string;
    };
    unpackFromCell(args: {
        structure: nt.AbiParam[];
        boc: string;
        allowPartial: boolean;
        abiVersion?: AbiVersion;
    }): nt.TokensObject;
    getBocHash(boc: string): string;
    extendSignature(signature: string): nt.ExtendedSignature;
    encodeInternalInput(args: ever.FunctionCall<string>): string;
    encodeInternalMessage(args: {
        src?: string;
        dst: string;
        bounce: boolean;
        stateInit?: string;
        body?: string;
        amount: string;
    }): string;
    createExternalMessage(args: {
        address: string | Address;
        signer: Signer;
        timeout: number;
        abi: string;
        method: string;
        params: nt.TokensObject;
        stateInit?: string;
        signatureId?: number;
    }): Promise<nt.SignedMessage>;
    createRawExternalMessage(args: {
        address: string | Address;
        body?: string;
        stateInit?: string;
        expireAt: number;
    }): nt.SignedMessage;
}
/**
 * @category AccountsStorage
 */
export declare class SimpleAccountsStorage implements AccountsStorage {
    private _defaultAccount;
    private readonly accounts;
    /**
     * Creates new simple accounts storage.
     *
     * If no `defaultAccount` provided, uses first provided entry
     *
     * @param args
     */
    constructor(args?: {
        defaultAccount?: Address | string;
        entries?: Iterable<Account>;
    });
    get defaultAccount(): Address | undefined;
    set defaultAccount(value: Address | string | undefined);
    getAccount(address: string | Address): Promise<Account | undefined>;
    addAccount(account: Account): Address;
    hasAccount(address: string | Address): boolean;
    removeAccount(address: string | Address): void;
}
