"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleAccountsStorage = exports.AccountsStorageContext = exports.EverWalletAccount = exports.HighloadWalletV2 = exports.WalletV3Account = exports.MsigAccount = exports.GenericAccount = exports.GiverAccount = void 0;
const utils_1 = require("../utils");
var Giver_1 = require("./Giver");
Object.defineProperty(exports, "GiverAccount", { enumerable: true, get: function () { return Giver_1.GiverAccount; } });
var Generic_1 = require("./Generic");
Object.defineProperty(exports, "GenericAccount", { enumerable: true, get: function () { return Generic_1.GenericAccount; } });
Object.defineProperty(exports, "MsigAccount", { enumerable: true, get: function () { return Generic_1.MsigAccount; } });
var WalletV3_1 = require("./WalletV3");
Object.defineProperty(exports, "WalletV3Account", { enumerable: true, get: function () { return WalletV3_1.WalletV3Account; } });
var HighloadWalletV2_1 = require("./HighloadWalletV2");
Object.defineProperty(exports, "HighloadWalletV2", { enumerable: true, get: function () { return HighloadWalletV2_1.HighloadWalletV2; } });
var EverWallet_1 = require("./EverWallet");
Object.defineProperty(exports, "EverWalletAccount", { enumerable: true, get: function () { return EverWallet_1.EverWalletAccount; } });
/**
 * @category AccountsStorage
 */
class AccountsStorageContext {
    constructor(clock, connectionController, nekoton, keystore) {
        this.clock = clock;
        this.connectionController = connectionController;
        this.nekoton = nekoton;
        this.keystore = keystore;
    }
    async getSigner(publicKey) {
        if (this.keystore == null) {
            throw new Error('Keystore not found');
        }
        const signer = await this.keystore.getSigner(publicKey);
        if (signer == null) {
            throw new Error('Signer not found');
        }
        return signer;
    }
    get nowMs() {
        return this.clock.nowMs;
    }
    get nowSec() {
        return ~~(this.clock.nowMs / 1000);
    }
    async fetchPublicKey(address) {
        const state = await this.getFullContractState(address);
        if (state == null || !state.isDeployed) {
            throw new Error('Contract not deployed');
        }
        return this.nekoton.extractPublicKey(state.boc);
    }
    async getFullContractState(address) {
        return this.connectionController.use(async ({ data: { transport } }) => transport.getFullContractState(address.toString()));
    }
    extractContractData(boc) {
        return this.nekoton.extractContractData(boc);
    }
    packIntoCell(args) {
        return this.nekoton.packIntoCell(args.structure, args.data, args.abiVersion);
    }
    unpackFromCell(args) {
        return this.nekoton.unpackFromCell(args.structure, args.boc, args.allowPartial, args.abiVersion);
    }
    getBocHash(boc) {
        return this.nekoton.getBocHash(boc);
    }
    extendSignature(signature) {
        return this.nekoton.extendSignature(signature);
    }
    encodeInternalInput(args) {
        return this.nekoton.encodeInternalInput(args.abi, args.method, args.params);
    }
    encodeInternalMessage(args) {
        return this.nekoton.encodeInternalMessage(args.src, args.dst, args.bounce, args.stateInit, args.body, args.amount);
    }
    async createExternalMessage(args) {
        const unsignedMessage = this.nekoton.createExternalMessage(this.clock, args.address.toString(), args.abi, args.method, args.stateInit, args.params, args.signer.publicKey, args.timeout);
        try {
            const signature = await args.signer.sign(unsignedMessage.hash, args.signatureId);
            return unsignedMessage.sign(signature);
        }
        finally {
            unsignedMessage.free();
        }
    }
    createRawExternalMessage(args) {
        return this.nekoton.createRawExternalMessage(args.address.toString(), args.stateInit, args.body, args.expireAt);
    }
}
exports.AccountsStorageContext = AccountsStorageContext;
/**
 * @category AccountsStorage
 */
class SimpleAccountsStorage {
    /**
     * Creates new simple accounts storage.
     *
     * If no `defaultAccount` provided, uses first provided entry
     *
     * @param args
     */
    constructor(args = {}) {
        this.accounts = new Map();
        if (args.entries != null) {
            for (const account of args.entries) {
                if (this._defaultAccount == null) {
                    this._defaultAccount = account.address;
                }
                this.accounts.set(account.address.toString(), account);
            }
        }
        if (args.defaultAccount != null) {
            const defaultAccount = (0, utils_1.convertToAddressObject)(args.defaultAccount);
            if (!this.accounts.has(defaultAccount.toString())) {
                throw new Error('Provided default account not found in storage');
            }
            this._defaultAccount = defaultAccount;
        }
    }
    get defaultAccount() {
        return this._defaultAccount;
    }
    set defaultAccount(value) {
        const address = value === null || value === void 0 ? void 0 : value.toString();
        if (address != null && !this.accounts.has(address)) {
            throw new Error('Account not found in storage');
        }
        this._defaultAccount = value == null ? value : (0, utils_1.convertToAddressObject)(value);
    }
    async getAccount(address) {
        return this.accounts.get(address.toString());
    }
    addAccount(account) {
        const address = account.address;
        this.accounts.set(address.toString(), account);
        return address;
    }
    hasAccount(address) {
        return this.accounts.has(address.toString());
    }
    removeAccount(address) {
        this.accounts.delete(address.toString());
    }
}
exports.SimpleAccountsStorage = SimpleAccountsStorage;
