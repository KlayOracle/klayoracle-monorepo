"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GqlSocket = void 0;
const core_1 = __importDefault(require("../../core"));
const { nekoton, fetch, fetchAgent, debugLog } = core_1.default;
class GqlSocket {
    async connect(clock, params) {
        class GqlSender {
            constructor(params) {
                this.nextLatencyDetectionTime = 0;
                this.local = params.local === true;
                this.maxLatency = params.maxLatency || 60000;
                this.latencyDetectionInterval = params.latencyDetectionInterval || 60000;
                this.endpoints = params.endpoints.map(GqlSocket.expandAddress);
                if (this.endpoints.length == 1) {
                    this.currentEndpoint = this.endpoints[0];
                    this.nextLatencyDetectionTime = Number.MAX_VALUE;
                }
            }
            isLocal() {
                return this.local;
            }
            send(data, handler, _longQuery) {
                (async () => {
                    const now = Date.now();
                    try {
                        let endpoint;
                        if (this.currentEndpoint != null && now < this.nextLatencyDetectionTime) {
                            // Default route
                            endpoint = this.currentEndpoint;
                        }
                        else if (this.resolutionPromise != null) {
                            // Already resolving
                            endpoint = await this.resolutionPromise;
                            delete this.resolutionPromise;
                        }
                        else {
                            delete this.currentEndpoint;
                            // Start resolving (current endpoint is null, or it is time to refresh)
                            this.resolutionPromise = this._selectQueryingEndpoint().then(endpoint => {
                                this.currentEndpoint = endpoint;
                                this.nextLatencyDetectionTime = Date.now() + this.latencyDetectionInterval;
                                return endpoint;
                            });
                            endpoint = await this.resolutionPromise;
                            delete this.resolutionPromise;
                        }
                        const response = await fetch(endpoint.url, {
                            method: 'post',
                            headers: DEFAULT_HEADERS,
                            body: data,
                            agent: endpoint.agent,
                        }).then(response => response.text());
                        handler.onReceive(response);
                    }
                    catch (e) {
                        handler.onError(e);
                    }
                })();
            }
            async _selectQueryingEndpoint() {
                const maxLatency = this.maxLatency;
                const endpointCount = this.endpoints.length;
                for (let retryCount = 0; retryCount < 5; ++retryCount) {
                    let handlers;
                    const promise = new Promise((resolve, reject) => {
                        handlers = {
                            resolve: (endpoint) => resolve(endpoint),
                            reject: () => reject(undefined),
                        };
                    });
                    let checkedEndpoints = 0;
                    let lastLatency;
                    for (const endpoint of this.endpoints) {
                        GqlSocket.checkLatency(endpoint).then(latency => {
                            ++checkedEndpoints;
                            if (latency !== undefined && latency <= maxLatency) {
                                return handlers.resolve(endpoint);
                            }
                            if (lastLatency === undefined ||
                                lastLatency.latency === undefined ||
                                (latency !== undefined && latency < lastLatency.latency)) {
                                lastLatency = { endpoint, latency };
                            }
                            if (checkedEndpoints >= endpointCount) {
                                if ((lastLatency === null || lastLatency === void 0 ? void 0 : lastLatency.latency) !== undefined) {
                                    handlers.resolve(lastLatency.endpoint);
                                }
                                else {
                                    handlers.reject();
                                }
                            }
                        });
                    }
                    try {
                        return await promise;
                    }
                    catch (e) {
                        let resolveDelay;
                        const delayPromise = new Promise(resolve => {
                            resolveDelay = () => resolve();
                        });
                        setTimeout(() => resolveDelay(), Math.min(100 * retryCount, 5000));
                        await delayPromise;
                    }
                }
                throw new Error('Not available endpoint found');
            }
        }
        return new nekoton.GqlConnection(clock, new GqlSender(params));
    }
    static async checkLatency(endpoint) {
        const response = (await fetch(`${endpoint.url}?query=%7Binfo%7Bversion%20time%20latency%7D%7D`, {
            method: 'get',
            agent: endpoint.agent,
        })
            .then(response => response.json())
            .catch((e) => {
            debugLog(e);
            return undefined;
        }));
        if (typeof response !== 'object' || response == null) {
            return;
        }
        const data = response['data'];
        if (typeof data !== 'object' || data == null) {
            return;
        }
        const info = data['info'];
        if (typeof info !== 'object' || info == null) {
            return;
        }
        const latency = info['latency'];
        if (typeof latency !== 'number') {
            return;
        }
        return latency;
    }
}
exports.GqlSocket = GqlSocket;
GqlSocket.expandAddress = (baseUrl) => {
    const lastBackslashIndex = baseUrl.lastIndexOf('/');
    baseUrl = lastBackslashIndex < 0 ? baseUrl : baseUrl.substring(0, lastBackslashIndex);
    let url;
    if (baseUrl.startsWith('http://') || baseUrl.startsWith('https://')) {
        url = `${baseUrl}/graphql`;
    }
    else if (['localhost', '127.0.0.1'].indexOf(baseUrl) >= 0) {
        url = `http://${baseUrl}/graphql`;
    }
    else {
        url = `https://${baseUrl}/graphql`;
    }
    return {
        url,
        agent: fetchAgent(url),
    };
};
const DEFAULT_HEADERS = {
    'Content-Type': 'application/json',
};
