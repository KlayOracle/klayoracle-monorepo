"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionController = exports.createConnectionController = exports.ConnectionError = exports.checkConnection = exports.NETWORK_PRESETS = void 0;
const await_semaphore_1 = require("@broxus/await-semaphore");
const core_1 = __importDefault(require("../../core"));
const gql_1 = require("./gql");
const jrpc_1 = require("./jrpc");
const { nekoton, debugLog } = core_1.default;
/**
 * @category Client
 */
exports.NETWORK_PRESETS = {
    mainnetJrpc: {
        id: 1,
        type: 'jrpc',
        data: {
            endpoint: 'https://jrpc.everwallet.net/rpc',
        },
    },
    fld: {
        id: 10,
        type: 'graphql',
        data: {
            endpoints: ['gql.custler.net'],
            local: false,
        },
    },
    local: {
        id: 31337,
        type: 'graphql',
        data: {
            endpoints: ['127.0.0.1'],
            local: true,
        },
    },
};
const matchNetworkGroup = (id) => {
    switch (id) {
        case 1:
            return 'mainnet';
        case 2:
            return 'testnet';
        case 10:
            return 'fld';
        case 31337:
            return 'localnet';
        default:
            return `network${id}`;
    }
};
function loadPreset(params) {
    if (typeof params === 'string') {
        const targetPreset = exports.NETWORK_PRESETS[params];
        if (targetPreset == null) {
            throw new Error(`Target preset id not found: ${params}`);
        }
        return targetPreset;
    }
    else {
        return params;
    }
}
/**
 * Tries to connect with the specified params. Throws an exception in case of error
 *
 * @category Client
 * @throws ConnectionError
 */
async function checkConnection(params) {
    const preset = loadPreset(params);
    const clock = new nekoton.ClockWithOffset();
    try {
        const controller = new ConnectionController(clock);
        await controller['_connect'](preset);
        if (controller['_initializedTransport'] != null) {
            cleanupInitializedTransport(controller['_initializedTransport']);
        }
    }
    catch (e) {
        throw new ConnectionError(preset, e.toString());
    }
    finally {
        clock.free();
    }
}
exports.checkConnection = checkConnection;
/**
 * @category Client
 */
class ConnectionError extends Error {
    constructor(params, message) {
        super(message);
        this.params = params;
    }
}
exports.ConnectionError = ConnectionError;
async function createConnectionController(clock, params, retry = false) {
    const preset = loadPreset(params);
    // Try connect
    while (true) {
        try {
            const controller = new ConnectionController(clock);
            await controller.startSwitchingNetwork(preset).then(handle => handle.switch());
            debugLog(`Successfully connected to ${preset.group}`);
            return controller;
        }
        catch (e) {
            if (retry) {
                console.error('Connection failed:', e);
                await new Promise(resolve => {
                    setTimeout(() => resolve(), 5000);
                });
                debugLog('Restarting connection process');
            }
            else {
                throw e;
            }
        }
    }
}
exports.createConnectionController = createConnectionController;
class ConnectionController {
    constructor(clock) {
        this._networkMutex = new await_semaphore_1.Mutex();
        this._acquiredTransportCounter = 0;
        this._clock = clock;
    }
    async acquire() {
        requireInitializedTransport(this._initializedTransport);
        await this._acquireTransport();
        return {
            transport: this._initializedTransport,
            release: () => this._releaseTransport(),
        };
    }
    async use(f) {
        requireInitializedTransport(this._initializedTransport);
        await this._acquireTransport();
        return f(this._initializedTransport).finally(() => {
            this._releaseTransport();
        });
    }
    async startSwitchingNetwork(params) {
        var _a;
        class NetworkSwitchHandle {
            constructor(controller, release, params) {
                this._controller = controller;
                this._release = release;
                this._params = params;
            }
            async switch() {
                await this._controller._connect(this._params).finally(() => this._release());
            }
        }
        (_a = this._cancelTestTransport) === null || _a === void 0 ? void 0 : _a.call(this);
        const release = await this._networkMutex.acquire();
        return new NetworkSwitchHandle(this, release, params);
    }
    get initializedTransport() {
        return this._initializedTransport;
    }
    async _connect(params) {
        if (this._initializedTransport != null) {
            cleanupInitializedTransport(this._initializedTransport);
        }
        this._initializedTransport = undefined;
        let TestConnectionResult;
        (function (TestConnectionResult) {
            TestConnectionResult[TestConnectionResult["DONE"] = 0] = "DONE";
            TestConnectionResult[TestConnectionResult["CANCELLED"] = 1] = "CANCELLED";
        })(TestConnectionResult || (TestConnectionResult = {}));
        const testTransport = async ({ data: { transport } }, local) => {
            return new Promise((resolve, reject) => {
                this._cancelTestTransport = () => resolve(TestConnectionResult.CANCELLED);
                if (local) {
                    transport
                        .getAccountsByCodeHash('4e92716de61d456e58f16e4e867e3e93a7548321eace86301b51c8b80ca6239b', 1)
                        .then(() => resolve(TestConnectionResult.DONE))
                        .catch((e) => reject(e));
                }
                else {
                    // Try to get any account state
                    transport
                        .getFullContractState('-1:0000000000000000000000000000000000000000000000000000000000000000')
                        .then(() => resolve(TestConnectionResult.DONE))
                        .catch((e) => reject(e));
                }
                setTimeout(() => reject(new Error('Connection timeout')), 10000);
            }).finally(() => (this._cancelTestTransport = undefined));
        };
        try {
            const group = params.group != null ? params.group : matchNetworkGroup(params.id);
            const { local, transportData } = await (params.type === 'graphql'
                ? async () => {
                    const socket = new gql_1.GqlSocket();
                    const connection = await socket.connect(this._clock, params.data);
                    const transport = nekoton.Transport.fromGqlConnection(connection);
                    const transportData = {
                        id: params.id,
                        group,
                        type: 'graphql',
                        data: {
                            socket,
                            connection,
                            transport,
                        },
                    };
                    return {
                        local: params.data.local === true,
                        transportData,
                    };
                }
                : async () => {
                    const socket = new jrpc_1.JrpcSocket();
                    const connection = await socket.connect(this._clock, params.data);
                    const transport = nekoton.Transport.fromJrpcConnection(connection);
                    const transportData = {
                        id: params.id,
                        group,
                        type: 'jrpc',
                        data: {
                            socket,
                            connection,
                            transport,
                        },
                    };
                    return {
                        local: false,
                        transportData,
                    };
                })();
            try {
                if ((await testTransport(transportData, local)) == TestConnectionResult.CANCELLED) {
                    cleanupInitializedTransport(transportData);
                    return;
                }
            }
            catch (e) {
                // Free transport data in case of error
                cleanupInitializedTransport(transportData);
                throw e;
            }
            this._initializedTransport = transportData;
        }
        catch (e) {
            throw new Error(`Failed to create connection: ${e.toString()}`);
        }
    }
    async _acquireTransport() {
        debugLog('_acquireTransport');
        if (this._acquiredTransportCounter > 0) {
            debugLog('_acquireTransport -> increase');
            this._acquiredTransportCounter += 1;
        }
        else {
            this._acquiredTransportCounter = 1;
            if (this._release != null) {
                console.warn('mutex is already acquired');
            }
            else {
                debugLog('_acquireTransport -> await');
                this._release = await this._networkMutex.acquire();
                debugLog('_acquireTransport -> create');
            }
        }
    }
    _releaseTransport() {
        var _a;
        debugLog('_releaseTransport');
        this._acquiredTransportCounter -= 1;
        if (this._acquiredTransportCounter <= 0) {
            debugLog('_releaseTransport -> release');
            (_a = this._release) === null || _a === void 0 ? void 0 : _a.call(this);
            this._release = undefined;
        }
    }
}
exports.ConnectionController = ConnectionController;
function cleanupInitializedTransport(transport) {
    transport.data.transport.free();
    transport.data.connection.free();
}
function requireInitializedTransport(transport) {
    if (transport == null) {
        throw new Error('Connection is not initialized');
    }
}
