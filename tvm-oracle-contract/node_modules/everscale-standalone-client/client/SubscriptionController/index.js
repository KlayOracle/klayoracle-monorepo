"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubscriptionController = void 0;
const await_semaphore_1 = require("@broxus/await-semaphore");
const utils_1 = require("../utils");
const subscription_1 = require("./subscription");
const DEFAULT_POLLING_INTERVAL = 10000; // 10s
class SubscriptionController {
    constructor(connectionController, notify) {
        this._subscriptions = new Map();
        this._subscriptionsMutex = new await_semaphore_1.Mutex();
        this._sendMessageRequests = new Map();
        this._subscriptionStates = new Map();
        this._connectionController = connectionController;
        this._notify = notify;
    }
    async sendMessageLocally(address, signedMessage, params) {
        const subscriptionId = (0, utils_1.getUniqueId)();
        try {
            await this.subscribeToContract(address, { state: true }, subscriptionId);
            const subscription = this._subscriptions.get(address);
            if (subscription == null) {
                throw new Error('Failed to subscribe to contract');
            }
            return await subscription.use(contract => contract.sendMessageLocally(signedMessage, params));
        }
        finally {
            this.unsubscribeFromContract(address, subscriptionId).catch(console.error);
        }
    }
    sendMessage(address, signedMessage) {
        let messageRequests = this._sendMessageRequests.get(address);
        if (messageRequests == null) {
            messageRequests = new Map();
            this._sendMessageRequests.set(address, messageRequests);
        }
        const subscriptionId = (0, utils_1.getUniqueId)();
        return new Promise((resolve, reject) => {
            const id = signedMessage.hash;
            messageRequests.set(id, { resolve, reject });
            this.subscribeToContract(address, { state: true }, subscriptionId)
                .then(async () => {
                const subscription = this._subscriptions.get(address);
                if (subscription == null) {
                    throw new Error('Failed to subscribe to contract');
                }
                await subscription.prepareReliablePolling();
                await subscription.use(async (contract) => {
                    await contract.sendMessage(signedMessage);
                    subscription.skipRefreshTimer(contract.pollingMethod);
                });
            })
                .catch((e) => this._rejectMessageRequest(address, id, e))
                .finally(() => {
                this.unsubscribeFromContract(address, subscriptionId).catch(console.error);
            });
        });
    }
    async subscribeToContract(address, params, internalId) {
        return this._subscriptionsMutex.use(async () => {
            const mergeInputParams = (currentParams) => {
                const newParams = { ...currentParams };
                Object.keys(newParams).map(param => {
                    if (param !== 'state' && param !== 'transactions') {
                        throw new Error(`Unknown subscription topic: ${param}`);
                    }
                    const value = params[param];
                    if (typeof value === 'boolean') {
                        newParams[param] = value;
                    }
                    else if (value == null) {
                        return;
                    }
                    else {
                        throw new Error(`Unknown subscription topic value ${param}: ${value}`);
                    }
                });
                return newParams;
            };
            const subscriptionState = this._subscriptionStates.get(address) || makeDefaultSubscriptionState();
            let changedParams;
            if (internalId == null) {
                // Client subscription without id
                // Changed params are `SubscriptionState.client`
                changedParams = mergeInputParams(subscriptionState.client);
            }
            else {
                // Internal subscription with id
                // Changed params are `SubscriptionState.internal[internalId]`
                const exisingParams = subscriptionState.internal.get(internalId);
                if (exisingParams != null) {
                    // Updating existing internal params
                    changedParams = mergeInputParams(exisingParams);
                    // Remove entry if it is empty
                    if (isEmptySubscription(changedParams)) {
                        subscriptionState.internal.delete(internalId);
                    }
                }
                else {
                    // Merge input params with empty struct
                    changedParams = mergeInputParams({ state: false, transactions: false });
                }
            }
            // Merge changed params with the rest of internal params
            const computedParams = { ...changedParams };
            for (const params of subscriptionState.internal.values()) {
                computedParams.state || (computedParams.state = params.state);
                computedParams.transactions || (computedParams.transactions = params.transactions);
            }
            // Remove subscription if all params are empty
            if (isEmptySubscription(computedParams)) {
                this._subscriptionStates.delete(address);
                await this._tryUnsubscribe(address);
                return { ...computedParams };
            }
            // Create subscription if it doesn't exist
            let existingSubscription = this._subscriptions.get(address);
            const isNewSubscription = existingSubscription == null;
            if (existingSubscription == null) {
                existingSubscription = await this._createSubscription(address);
            }
            // Update subscription state
            if (internalId == null) {
                // Update client params
                subscriptionState.client = changedParams;
            }
            else {
                // Set new internal params
                subscriptionState.internal.set(internalId, changedParams);
            }
            this._subscriptionStates.set(address, subscriptionState);
            // Start subscription
            if (isNewSubscription) {
                await existingSubscription.start();
            }
            // Returns only changed params
            return { ...changedParams };
        });
    }
    async unsubscribeFromContract(address, internalId) {
        await this.subscribeToContract(address, {
            state: false,
            transactions: false,
        }, internalId);
    }
    async unsubscribeFromAllContracts(internalId) {
        for (const address of this._subscriptions.keys()) {
            await this.unsubscribeFromContract(address, internalId);
        }
    }
    get subscriptionStates() {
        const result = {};
        for (const [key, value] of this._subscriptionStates.entries()) {
            result[key] = { ...value.client };
        }
        return result;
    }
    async _createSubscription(address) {
        class ContractHandler {
            constructor(address, controller) {
                this._enabled = false;
                this._address = address;
                this._controller = controller;
            }
            enableNotifications() {
                this._enabled = true;
            }
            onMessageExpired(pendingTransaction) {
                this._controller
                    ._resolveMessageRequest(this._address, pendingTransaction.messageHash, undefined)
                    .catch(console.error);
            }
            onMessageSent(pendingTransaction, transaction) {
                this._controller
                    ._resolveMessageRequest(this._address, pendingTransaction.messageHash, transaction)
                    .catch(console.error);
            }
            onStateChanged(newState) {
                if (this._enabled) {
                    this._controller._notifyStateChanged(this._address, newState);
                }
            }
            onTransactionsFound(transactions, info) {
                if (this._enabled) {
                    this._controller._notifyTransactionsFound(this._address, transactions, info);
                }
            }
        }
        const handler = new ContractHandler(address, this);
        const subscription = await subscription_1.ContractSubscription.subscribe(this._connectionController, address, handler);
        subscription.setPollingInterval(DEFAULT_POLLING_INTERVAL);
        handler.enableNotifications();
        this._subscriptions.set(address, subscription);
        return subscription;
    }
    async _tryUnsubscribe(address) {
        const subscriptionState = this._subscriptionStates.get(address);
        const sendMessageRequests = this._sendMessageRequests.get(address);
        if (subscriptionState == null && ((sendMessageRequests === null || sendMessageRequests === void 0 ? void 0 : sendMessageRequests.size) || 0) == 0) {
            const subscription = this._subscriptions.get(address);
            this._subscriptions.delete(address);
            await (subscription === null || subscription === void 0 ? void 0 : subscription.stop());
        }
    }
    async _rejectMessageRequest(address, id, error) {
        this._deleteMessageRequestAndGetCallback(address, id).reject(error);
        await this._subscriptionsMutex.use(async () => this._tryUnsubscribe(address));
    }
    async _resolveMessageRequest(address, id, transaction) {
        this._deleteMessageRequestAndGetCallback(address, id).resolve(transaction);
        await this._subscriptionsMutex.use(async () => this._tryUnsubscribe(address));
    }
    _notifyStateChanged(address, state) {
        const subscriptionState = this._subscriptionStates.get(address);
        if (subscriptionState === null || subscriptionState === void 0 ? void 0 : subscriptionState.client.state) {
            this._notify('contractStateChanged', {
                address,
                state,
            });
        }
    }
    _notifyTransactionsFound(address, transactions, info) {
        const subscriptionState = this._subscriptionStates.get(address);
        if (subscriptionState === null || subscriptionState === void 0 ? void 0 : subscriptionState.client.transactions) {
            this._notify('transactionsFound', {
                address,
                transactions,
                info,
            });
        }
    }
    _deleteMessageRequestAndGetCallback(address, id) {
        var _a;
        const callbacks = (_a = this._sendMessageRequests.get(address)) === null || _a === void 0 ? void 0 : _a.get(id);
        if (!callbacks) {
            throw new Error(`SendMessage request with id '${id}' not found`);
        }
        this._deleteMessageRequest(address, id);
        return callbacks;
    }
    _deleteMessageRequest(address, id) {
        const accountMessageRequests = this._sendMessageRequests.get(address);
        if (!accountMessageRequests) {
            return;
        }
        accountMessageRequests.delete(id);
        if (accountMessageRequests.size == 0) {
            this._sendMessageRequests.delete(address);
        }
    }
}
exports.SubscriptionController = SubscriptionController;
const makeDefaultSubscriptionState = () => ({
    internal: new Map(),
    client: {
        state: false,
        transactions: false,
    },
});
const isEmptySubscription = (params) => !params.state && !params.transactions;
