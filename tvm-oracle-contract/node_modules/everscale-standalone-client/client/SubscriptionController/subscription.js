"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractSubscription = void 0;
const await_semaphore_1 = require("@broxus/await-semaphore");
const core_1 = __importDefault(require("../../core"));
const { nekoton, debugLog } = core_1.default;
class ContractSubscription {
    static async subscribe(connectionController, address, handler) {
        const { transport: { data: { connection, transport }, }, release, } = await connectionController.acquire();
        try {
            const contract = await transport.subscribeToGenericContract(address, handler);
            if (contract == null) {
                throw new Error(`Failed to subscribe to contract: ${address}`);
            }
            return new ContractSubscription(connection, release, address, contract);
        }
        catch (e) {
            release();
            throw e;
        }
    }
    constructor(connection, release, address, contract) {
        this._contractMutex = new await_semaphore_1.Mutex();
        this._pollingInterval = BACKGROUND_POLLING_INTERVAL;
        this._isRunning = false;
        this._skipIteration = false;
        this._connection = connection;
        this._address = address;
        this._contract = contract;
        this._releaseTransport = release;
        this._currentPollingMethod = contract.pollingMethod;
    }
    setPollingInterval(interval) {
        this._pollingInterval = interval;
    }
    async start() {
        if (this._releaseTransport == null) {
            throw new Error('Contract subscription must not be started after being closed');
        }
        if (this._loopPromise) {
            debugLog('ContractSubscription -> awaiting loop promise');
            await this._loopPromise;
        }
        debugLog('ContractSubscription -> loop started');
        this._loopPromise = (async () => {
            const isSimple = !(this._connection instanceof nekoton.GqlConnection);
            this._isRunning = true;
            let previousPollingMethod = this._currentPollingMethod;
            while (this._isRunning) {
                this._skipIteration = false; // always reset this flag
                const pollingMethodChanged = previousPollingMethod != this._currentPollingMethod;
                previousPollingMethod = this._currentPollingMethod;
                if (isSimple || this._currentPollingMethod == 'manual') {
                    this._currentBlockId = undefined;
                    debugLog('ContractSubscription -> manual -> waiting begins');
                    const pollingInterval = this._currentPollingMethod == 'manual' ? this._pollingInterval : INTENSIVE_POLLING_INTERVAL;
                    await new Promise(resolve => {
                        const timerHandle = setTimeout(() => {
                            this._refreshTimer = undefined;
                            resolve();
                        }, pollingInterval);
                        this._refreshTimer = [timerHandle, resolve];
                    });
                    debugLog('ContractSubscription -> manual -> waiting ends');
                    if (this._skipIteration) {
                        continue;
                    }
                    if (!this._isRunning) {
                        break;
                    }
                    debugLog('ContractSubscription -> manual -> refreshing begins');
                    try {
                        this._currentPollingMethod = await this._contractMutex.use(async () => {
                            await this._contract.refresh();
                            return this._contract.pollingMethod;
                        });
                    }
                    catch (e) {
                        console.error(`Error during account refresh (${this._address})`, e);
                    }
                    debugLog('ContractSubscription -> manual -> refreshing ends');
                }
                else {
                    // SAFETY: connection is always GqlConnection here due to `isSimple`
                    const connection = this._connection;
                    debugLog('ContractSubscription -> reliable start');
                    if (pollingMethodChanged && this._suggestedBlockId != null) {
                        this._currentBlockId = this._suggestedBlockId;
                    }
                    this._suggestedBlockId = undefined;
                    let nextBlockId;
                    if (this._currentBlockId == null) {
                        console.warn('Starting reliable connection with unknown block');
                        try {
                            const latestBlock = await connection.getLatestBlock(this._address);
                            this._currentBlockId = latestBlock.id;
                            nextBlockId = this._currentBlockId;
                        }
                        catch (e) {
                            console.error(`Failed to get latest block for ${this._address}`, e);
                            continue;
                        }
                    }
                    else {
                        try {
                            nextBlockId = await connection.waitForNextBlock(this._currentBlockId, this._address, NEXT_BLOCK_TIMEOUT);
                        }
                        catch (e) {
                            console.error(`Failed to wait for next block for ${this._address}`);
                            continue; // retry
                        }
                    }
                    try {
                        this._currentPollingMethod = await this._contractMutex.use(async () => {
                            await this._contract.handleBlock(nextBlockId);
                            return this._contract.pollingMethod;
                        });
                        this._currentBlockId = nextBlockId;
                    }
                    catch (e) {
                        console.error(`Failed to handle block for ${this._address}`, e);
                    }
                }
            }
            debugLog('ContractSubscription -> loop finished');
        })();
    }
    skipRefreshTimer(pollingMethod) {
        var _a, _b;
        if (pollingMethod != null) {
            this._currentPollingMethod = pollingMethod;
            this._skipIteration = true;
        }
        clearTimeout((_a = this._refreshTimer) === null || _a === void 0 ? void 0 : _a[0]);
        (_b = this._refreshTimer) === null || _b === void 0 ? void 0 : _b[1]();
        this._refreshTimer = undefined;
    }
    async pause() {
        if (!this._isRunning) {
            return;
        }
        this._isRunning = false;
        this.skipRefreshTimer();
        await this._loopPromise;
        this._loopPromise = undefined;
        this._currentPollingMethod = await this._contractMutex.use(async () => {
            return this._contract.pollingMethod;
        });
        this._currentBlockId = undefined;
        this._suggestedBlockId = undefined;
    }
    async stop() {
        var _a;
        await this.pause();
        this._contract.free();
        (_a = this._releaseTransport) === null || _a === void 0 ? void 0 : _a.call(this);
        this._releaseTransport = undefined;
    }
    async prepareReliablePolling() {
        try {
            if (this._connection instanceof nekoton.GqlConnection) {
                this._suggestedBlockId = (await this._connection.getLatestBlock(this._address)).id;
            }
        }
        catch (e) {
            throw new Error(`Failed to prepare reliable polling: ${e.toString()}`);
        }
    }
    async use(f) {
        const release = await this._contractMutex.acquire();
        return f(this._contract)
            .then(res => {
            release();
            return res;
        })
            .catch(err => {
            release();
            throw err;
        });
    }
}
exports.ContractSubscription = ContractSubscription;
const NEXT_BLOCK_TIMEOUT = 60; // 60s
const INTENSIVE_POLLING_INTERVAL = 2000; // 2s
const BACKGROUND_POLLING_INTERVAL = 60000;
