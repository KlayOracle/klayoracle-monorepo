import type * as ever from 'everscale-inpage-provider';
import type * as nt from 'nekoton-wasm';
import { SafeEventEmitter } from './utils';
import { ConnectionProperties } from './ConnectionController';
import { AccountsStorage } from './AccountsStorage';
import { Keystore } from './keystore';
import { Clock } from './clock';
export { NETWORK_PRESETS, ConnectionData, ConnectionProperties } from './ConnectionController';
export { GqlSocketParams, JrpcSocketParams, ConnectionError, checkConnection } from './ConnectionController';
export * from './AccountsStorage';
export { Keystore, Signer, SimpleKeystore } from './keystore';
export { Clock } from './clock';
export type { Ed25519KeyPair } from 'nekoton-wasm';
/**
 * Standalone provider which is used as a fallback when browser extension is not installed
 *
 * @category Client
 */
export type ClientProperties = {
    /**
     * Connection properties or network preset name
     */
    connection?: ConnectionProperties;
    /**
     * Keystore which will be used for all methods with `accountInteraction`
     */
    keystore?: Keystore;
    /**
     * Accounts storage which will be used to send internal messages
     */
    accountsStorage?: AccountsStorage;
    /**
     * Clock object which can be used to adjust time offset
     */
    clock?: Clock;
    /**
     * Message behaviour properties
     */
    message?: MessageProperties;
    /**
     * Explicit params for nekoton wasm loader
     */
    initInput?: nt.InitInput | Promise<nt.InitInput>;
};
/**
 * Message behaviour properties
 *
 * @category Client
 */
export type MessageProperties = {
    /**
     * Number of attempts to send a message
     *
     * @default 5
     */
    retryCount?: number;
    /**
     * Message expiration timeout (seconds)
     *
     * @default 60
     */
    timeout?: number;
    /**
     * Message expiration timeout grow factor for each new retry
     *
     * @default 1.2
     */
    timeoutGrowFactor?: number;
    /**
     * Retry internal transfers (`sendMessage` / `sendMessageDelayed`)
     *
     * @default true
     */
    retryTransfers?: boolean;
};
/**
 * @category Client
 */
export declare const VERSION = "0.2.25";
/**
 * @category Client
 */
export declare const SUPPORTED_PERMISSIONS: ever.Permission[];
/**
 * @category Client
 */
export declare class EverscaleStandaloneClient extends SafeEventEmitter implements ever.Provider {
    private readonly _context;
    private _handlers;
    static create(params?: ClientProperties): Promise<EverscaleStandaloneClient>;
    static setDebugLogger(logger: (...data: any[]) => void): void;
    private constructor();
    request<T extends ever.ProviderMethod>(req: ever.RawProviderRequest<T>): Promise<ever.RawProviderApiResponse<T>>;
    addListener<T extends ever.ProviderEvent>(eventName: T, listener: (data: ever.RawProviderEventData<T>) => void): this;
    removeListener<T extends ever.ProviderEvent>(eventName: T, listener: (data: ever.RawProviderEventData<T>) => void): this;
    on<T extends ever.ProviderEvent>(eventName: T, listener: (data: ever.RawProviderEventData<T>) => void): this;
    once<T extends ever.ProviderEvent>(eventName: T, listener: (data: ever.RawProviderEventData<T>) => void): this;
    prependListener<T extends ever.ProviderEvent>(eventName: T, listener: (data: ever.RawProviderEventData<T>) => void): this;
    prependOnceListener<T extends ever.ProviderEvent>(eventName: T, listener: (data: ever.RawProviderEventData<T>) => void): this;
}
