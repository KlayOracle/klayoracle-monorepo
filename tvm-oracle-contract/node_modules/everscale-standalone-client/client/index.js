"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EverscaleStandaloneClient = exports.SUPPORTED_PERMISSIONS = exports.VERSION = exports.Clock = exports.SimpleKeystore = exports.checkConnection = exports.ConnectionError = exports.NETWORK_PRESETS = void 0;
const fast_safe_stringify_1 = __importDefault(require("fast-safe-stringify"));
const core_1 = __importDefault(require("../core"));
const utils_1 = require("./utils");
const ConnectionController_1 = require("./ConnectionController");
const SubscriptionController_1 = require("./SubscriptionController");
const AccountsStorage_1 = require("./AccountsStorage");
var ConnectionController_2 = require("./ConnectionController");
Object.defineProperty(exports, "NETWORK_PRESETS", { enumerable: true, get: function () { return ConnectionController_2.NETWORK_PRESETS; } });
var ConnectionController_3 = require("./ConnectionController");
Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function () { return ConnectionController_3.ConnectionError; } });
Object.defineProperty(exports, "checkConnection", { enumerable: true, get: function () { return ConnectionController_3.checkConnection; } });
__exportStar(require("./AccountsStorage"), exports);
var keystore_1 = require("./keystore");
Object.defineProperty(exports, "SimpleKeystore", { enumerable: true, get: function () { return keystore_1.SimpleKeystore; } });
var clock_1 = require("./clock");
Object.defineProperty(exports, "Clock", { enumerable: true, get: function () { return clock_1.Clock; } });
const { ensureNekotonLoaded, nekoton } = core_1.default;
function validateMessageProperties(message) {
    const m = message || {};
    return {
        retryCount: m.retryCount != null ? Math.max(1, ~~m.retryCount) : 5,
        timeout: m.timeout != null ? Math.max(1, ~~m.timeout) : 60,
        timeoutGrowFactor: m.timeoutGrowFactor || 1.2,
        retryTransfers: true,
    };
}
/**
 * @category Client
 */
exports.VERSION = '0.2.25';
/**
 * @category Client
 */
exports.SUPPORTED_PERMISSIONS = ['basic', 'accountInteraction'];
/**
 * @category Client
 */
class EverscaleStandaloneClient extends utils_1.SafeEventEmitter {
    static async create(params = {}) {
        await ensureNekotonLoaded(params.initInput);
        // NOTE: capture client inside notify using wrapper object
        const notificationContext = {};
        const notify = (method, params) => {
            var _a;
            (_a = notificationContext.client) === null || _a === void 0 ? void 0 : _a.emit(method, params);
        };
        const clock = new core_1.default.nekoton.ClockWithOffset();
        if (params.clock != null) {
            params.clock['impls'].push(clock);
            clock.updateOffset(params.clock.offset);
        }
        try {
            const connectionController = params.connection != null ? await (0, ConnectionController_1.createConnectionController)(clock, params.connection) : undefined;
            const subscriptionController = connectionController != null ? new SubscriptionController_1.SubscriptionController(connectionController, notify) : undefined;
            const client = new EverscaleStandaloneClient({
                permissions: {},
                connectionController,
                subscriptionController,
                properties: {
                    message: validateMessageProperties(params.message),
                },
                keystore: params.keystore,
                accountsStorage: params.accountsStorage,
                clock,
                notify,
            });
            // NOTE: WeakRef is not working here, so hope it will be garbage collected
            notificationContext.client = client;
            return client;
        }
        catch (e) {
            if (params.clock != null) {
                params.clock['impls'].pop();
            }
            clock.free();
            throw e;
        }
    }
    static setDebugLogger(logger) {
        core_1.default.debugLog = logger;
    }
    constructor(ctx) {
        super();
        this._handlers = {
            requestPermissions,
            changeAccount,
            disconnect,
            subscribe,
            unsubscribe,
            unsubscribeAll,
            getProviderState,
            getFullContractState,
            getAccountsByCodeHash,
            getTransactions,
            getTransaction,
            findTransaction,
            runLocal,
            executeLocal,
            getExpectedAddress,
            getContractFields,
            unpackInitData,
            getBocHash,
            packIntoCell,
            unpackFromCell,
            extractPublicKey,
            codeToTvc,
            mergeTvc,
            splitTvc,
            setCodeSalt,
            getCodeSalt,
            encodeInternalInput,
            decodeInput,
            decodeOutput,
            decodeEvent,
            decodeTransaction,
            decodeTransactionEvents,
            verifySignature,
            sendUnsignedExternalMessage,
            // addAsset, // not supported
            signData,
            signDataRaw,
            // encryptData, // not supported
            // decryptData, // not supported
            // estimateFees, // not supported
            sendMessage,
            sendMessageDelayed,
            sendExternalMessage,
            sendExternalMessageDelayed,
        };
        this._context = ctx;
    }
    request(req) {
        const handler = this._handlers[req.method];
        if (handler == null) {
            throw invalidRequest(req, `Method '${req.method}' is not supported by standalone provider`);
        }
        return handler(this._context, req);
    }
    addListener(eventName, listener) {
        return super.addListener(eventName, listener);
    }
    removeListener(eventName, listener) {
        return super.removeListener(eventName, listener);
    }
    on(eventName, listener) {
        return super.on(eventName, listener);
    }
    once(eventName, listener) {
        return super.once(eventName, listener);
    }
    prependListener(eventName, listener) {
        return super.prependListener(eventName, listener);
    }
    prependOnceListener(eventName, listener) {
        return super.prependOnceListener(eventName, listener);
    }
}
exports.EverscaleStandaloneClient = EverscaleStandaloneClient;
const requestPermissions = async (ctx, req) => {
    requireParams(req);
    const { permissions } = req.params;
    requireArray(req, req.params, 'permissions');
    const newPermissions = { ...ctx.permissions };
    for (const permission of permissions) {
        if (permission === 'basic' || permission === 'tonClient') {
            newPermissions.basic = true;
        }
        else if (permission === 'accountInteraction') {
            if (newPermissions.accountInteraction != null) {
                continue;
            }
            newPermissions.accountInteraction = await makeAccountInteractionPermission(req, ctx);
        }
        else {
            throw invalidRequest(req, `Permission '${permission}' is not supported by standalone provider`);
        }
    }
    ctx.permissions = newPermissions;
    // NOTE: be sure to return object copy to prevent adding new permissions
    const permissionsCopy = JSON.parse(JSON.stringify(newPermissions));
    ctx.notify('permissionsChanged', {
        permissions: permissionsCopy,
    });
    return permissionsCopy;
};
const changeAccount = async (ctx, req) => {
    requireAccountsStorage(req, ctx);
    const newPermissions = { ...ctx.permissions };
    newPermissions.accountInteraction = await makeAccountInteractionPermission(req, ctx);
    ctx.permissions = newPermissions;
    // NOTE: be sure to return object copy to prevent adding new permissions
    const permissionsCopy = JSON.parse(JSON.stringify(newPermissions));
    ctx.notify('permissionsChanged', {
        permissions: permissionsCopy,
    });
    return permissionsCopy;
};
const disconnect = async (ctx, _req) => {
    var _a;
    ctx.permissions = {};
    await ((_a = ctx.subscriptionController) === null || _a === void 0 ? void 0 : _a.unsubscribeFromAllContracts());
    ctx.notify('permissionsChanged', { permissions: {} });
    return undefined;
};
const subscribe = async (ctx, req) => {
    requireParams(req);
    requireConnection(req, ctx);
    const { address, subscriptions } = req.params;
    requireString(req, req.params, 'address');
    requireOptionalObject(req, req.params, 'subscriptions');
    let repackedAddress;
    try {
        repackedAddress = nekoton.repackAddress(address);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    try {
        return await ctx.subscriptionController.subscribeToContract(repackedAddress, subscriptions);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const unsubscribe = async (ctx, req) => {
    requireParams(req);
    requireConnection(req, ctx);
    const { address } = req.params;
    requireString(req, req.params, 'address');
    let repackedAddress;
    try {
        repackedAddress = nekoton.repackAddress(address);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    await ctx.subscriptionController.unsubscribeFromContract(repackedAddress);
    return undefined;
};
const unsubscribeAll = async (ctx, _req) => {
    var _a;
    await ((_a = ctx.subscriptionController) === null || _a === void 0 ? void 0 : _a.unsubscribeFromAllContracts());
    return undefined;
};
const getProviderState = async (ctx, _req) => {
    var _a, _b;
    const transport = (_a = ctx.connectionController) === null || _a === void 0 ? void 0 : _a.initializedTransport;
    const version = exports.VERSION;
    return {
        version,
        numericVersion: (0, utils_1.convertVersionToInt32)(version),
        networkId: transport != null ? transport.id : 0,
        selectedConnection: transport != null ? transport.group : '',
        supportedPermissions: [...exports.SUPPORTED_PERMISSIONS],
        permissions: JSON.parse(JSON.stringify(ctx.permissions)),
        subscriptions: ((_b = ctx.subscriptionController) === null || _b === void 0 ? void 0 : _b.subscriptionStates) || {},
    };
};
const getFullContractState = async (ctx, req) => {
    requireParams(req);
    requireConnection(req, ctx);
    const { address } = req.params;
    requireString(req, req.params, 'address');
    const { connectionController } = ctx;
    try {
        return connectionController.use(async ({ data: { transport } }) => ({
            state: await transport.getFullContractState(address),
        }));
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const getAccountsByCodeHash = async (ctx, req) => {
    requireParams(req);
    requireConnection(req, ctx);
    const { codeHash, limit, continuation } = req.params;
    requireString(req, req.params, 'codeHash');
    requireOptionalNumber(req, req.params, 'limit');
    requireOptionalString(req, req.params, 'continuation');
    const { connectionController } = ctx;
    try {
        return connectionController.use(({ data: { transport } }) => transport.getAccountsByCodeHash(codeHash, limit || 50, continuation));
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const getTransactions = async (ctx, req) => {
    requireParams(req);
    requireConnection(req, ctx);
    const { address, continuation, limit } = req.params;
    requireString(req, req.params, 'address');
    requireOptional(req, req.params, 'continuation', requireTransactionId);
    requireOptionalNumber(req, req.params, 'limit');
    const { connectionController } = ctx;
    try {
        return connectionController.use(({ data: { transport } }) => transport.getTransactions(address, continuation === null || continuation === void 0 ? void 0 : continuation.lt, limit || 50));
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const getTransaction = async (ctx, req) => {
    requireParams(req);
    requireConnection(req, ctx);
    const { hash } = req.params;
    requireString(req, req.params, 'hash');
    const { connectionController } = ctx;
    try {
        return {
            transaction: await connectionController.use(({ data: { transport } }) => transport.getTransaction(hash)),
        };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const findTransaction = async (ctx, req) => {
    requireParams(req);
    requireConnection(req, ctx);
    const { inMessageHash } = req.params;
    requireOptional(req, req.params, 'inMessageHash', requireString);
    const { connectionController } = ctx;
    // TODO: add more filters
    if (inMessageHash == null) {
        return {
            transaction: undefined,
        };
    }
    try {
        return {
            transaction: await connectionController.use(({ data: { transport } }) => transport.getDstTransaction(inMessageHash)),
        };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const runLocal = async (ctx, req) => {
    requireParams(req);
    const { address, cachedState, responsible, functionCall, withSignatureId } = req.params;
    requireString(req, req.params, 'address');
    requireOptional(req, req.params, 'cachedState', requireContractState);
    requireOptionalBoolean(req, req.params, 'responsible');
    requireFunctionCall(req, req.params, 'functionCall');
    requireOptionalSignatureId(req, req.params, 'withSignatureId');
    let contractState = cachedState;
    if (contractState == null) {
        requireConnection(req, ctx);
        contractState = await ctx.connectionController.use(async ({ data: { transport } }) => transport.getFullContractState(address));
    }
    if (contractState == null) {
        throw invalidRequest(req, 'Account not found');
    }
    if (!contractState.isDeployed || contractState.lastTransactionId == null) {
        throw invalidRequest(req, 'Account is not deployed');
    }
    const signatureId = await computeSignatureId(req, ctx, withSignatureId);
    try {
        const { output, code } = nekoton.runLocal(ctx.clock, contractState.boc, functionCall.abi, functionCall.method, functionCall.params, responsible || false, signatureId);
        return { output, code };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const executeLocal = async (ctx, req) => {
    requireParams(req);
    requireConnection(req, ctx);
    const { address, cachedState, stateInit, payload, executorParams, messageHeader } = req.params;
    requireString(req, req.params, 'address');
    requireOptional(req, req.params, 'cachedState', requireContractState);
    requireOptionalString(req, req.params, 'stateInit');
    requireOptionalRawFunctionCall(req, req.params, 'payload');
    requireOptionalObject(req, req.params, 'executorParams');
    requireObject(req, req.params, 'messageHeader');
    const { clock, connectionController } = ctx;
    let repackedAddress;
    try {
        repackedAddress = nekoton.repackAddress(address);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    const now = ~~(clock.nowMs / 1000);
    const timeout = 60;
    let message;
    if (messageHeader.type === 'external') {
        if (payload == null || typeof payload === 'string') {
            message = nekoton.createRawExternalMessage(repackedAddress, stateInit, payload, now + timeout).boc;
        }
        else if (messageHeader.withoutSignature === true) {
            message = nekoton.createExternalMessageWithoutSignature(clock, repackedAddress, payload.abi, payload.method, stateInit, payload.params, timeout).boc;
        }
        else {
            let unsignedMessage = nekoton.createExternalMessage(clock, repackedAddress, payload.abi, payload.method, stateInit, payload.params, messageHeader.publicKey, timeout);
            try {
                if ((executorParams === null || executorParams === void 0 ? void 0 : executorParams.disableSignatureCheck) === true) {
                    message = unsignedMessage.signFake().boc;
                }
                else {
                    requireKeystore(req, ctx);
                    const signatureId = await computeSignatureId(req, ctx);
                    const { keystore } = ctx;
                    const signer = await keystore.getSigner(messageHeader.publicKey);
                    if (signer == null) {
                        throw 'Signer not found for public key';
                    }
                    const signature = await signer.sign(unsignedMessage.hash, signatureId);
                    message = unsignedMessage.sign(signature).boc;
                }
            }
            catch (e) {
                throw invalidRequest(req, e.toString());
            }
            finally {
                unsignedMessage.free();
            }
        }
    }
    else if (messageHeader.type === 'internal') {
        requireString(req, messageHeader, 'sender');
        requireString(req, messageHeader, 'amount');
        requireBoolean(req, messageHeader, 'bounce');
        requireOptionalBoolean(req, messageHeader, 'bounced');
        const body = payload == null
            ? undefined
            : typeof payload === 'string'
                ? payload
                : nekoton.encodeInternalInput(payload.abi, payload.method, payload.params);
        message = nekoton.encodeInternalMessage(messageHeader.sender, repackedAddress, messageHeader.bounce, stateInit, body, messageHeader.amount);
    }
    else {
        throw invalidRequest(req, 'Unknown message type');
    }
    try {
        const [contractState, blockchainConfig, networkDescription] = await connectionController.use(({ data: { transport } }) => Promise.all([
            cachedState == null ? transport.getFullContractState(repackedAddress) : cachedState,
            transport.getBlockchainConfig(),
            transport.getNetworkDescription(),
        ]));
        const account = nekoton.makeFullAccountBoc(contractState === null || contractState === void 0 ? void 0 : contractState.boc);
        const overrideBalance = executorParams === null || executorParams === void 0 ? void 0 : executorParams.overrideBalance;
        const result = nekoton.executeLocal(blockchainConfig, account, message, now, (executorParams === null || executorParams === void 0 ? void 0 : executorParams.disableSignatureCheck) === true, overrideBalance != null ? overrideBalance.toString() : undefined, networkDescription.globalId);
        if (result.exitCode != null) {
            throw new Error(`Contract did not accept the message. Exit code: ${result.exitCode}`);
        }
        const resultVariant = result;
        const transaction = resultVariant.transaction;
        const newState = nekoton.parseFullAccountBoc(resultVariant.account);
        let output;
        try {
            if (typeof payload === 'object' && typeof payload != null) {
                const decoded = nekoton.decodeTransaction(resultVariant.transaction, payload.abi, payload.method);
                output = decoded === null || decoded === void 0 ? void 0 : decoded.output;
            }
        }
        catch (_) {
            /* do nothing */
        }
        return {
            transaction,
            newState,
            output,
        };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const getExpectedAddress = async (_ctx, req) => {
    requireParams(req);
    const { tvc, abi, workchain, publicKey, initParams } = req.params;
    requireString(req, req.params, 'tvc');
    requireString(req, req.params, 'abi');
    requireOptionalNumber(req, req.params, 'workchain');
    requireOptionalString(req, req.params, 'publicKey');
    try {
        return nekoton.getExpectedAddress(tvc, abi, workchain || 0, publicKey, initParams);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const getContractFields = async (ctx, req) => {
    requireParams(req);
    const { address, abi, cachedState, allowPartial } = req.params;
    requireString(req, req.params, 'address');
    requireString(req, req.params, 'abi');
    requireOptional(req, req.params, 'cachedState', requireContractState);
    requireBoolean(req, req.params, 'allowPartial');
    let repackedAddress;
    try {
        repackedAddress = nekoton.repackAddress(address);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    let contractState = cachedState;
    if (contractState == null) {
        requireConnection(req, ctx);
        contractState = await ctx.connectionController.use(async ({ data: { transport } }) => transport.getFullContractState(repackedAddress));
    }
    if (contractState == null) {
        return {
            fields: undefined,
            state: undefined,
        };
    }
    if (!contractState.isDeployed || contractState.lastTransactionId == null) {
        return {
            fields: undefined,
            state: contractState,
        };
    }
    try {
        const fields = nekoton.unpackContractFields(abi, contractState.boc, allowPartial);
        return {
            fields,
            state: contractState,
        };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const unpackInitData = async (_ctx, req) => {
    requireParams(req);
    const { abi, data } = req.params;
    requireString(req, req.params, 'abi');
    requireString(req, req.params, 'data');
    try {
        const { publicKey, data: initParams } = nekoton.unpackInitData(abi, data);
        return { publicKey, initParams };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const getBocHash = async (_ctx, req) => {
    requireParams(req);
    const { boc } = req.params;
    requireString(req, req.params, 'boc');
    try {
        return { hash: nekoton.getBocHash(boc) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const packIntoCell = async (_ctx, req) => {
    requireParams(req);
    const { structure, data, abiVersion } = req.params;
    requireArray(req, req.params, 'structure');
    requireOptional(req, req.params, 'abiVersion', requireString);
    try {
        return nekoton.packIntoCell(structure, data, abiVersion);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const unpackFromCell = async (_ctx, req) => {
    requireParams(req);
    const { structure, boc, allowPartial, abiVersion } = req.params;
    requireArray(req, req.params, 'structure');
    requireString(req, req.params, 'boc');
    requireBoolean(req, req.params, 'allowPartial');
    requireOptional(req, req.params, 'abiVersion', requireString);
    try {
        return { data: nekoton.unpackFromCell(structure, boc, allowPartial, abiVersion) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const extractPublicKey = async (_ctx, req) => {
    requireParams(req);
    const { boc } = req.params;
    requireString(req, req.params, 'boc');
    try {
        return { publicKey: nekoton.extractPublicKey(boc) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const codeToTvc = async (_ctx, req) => {
    requireParams(req);
    const { code } = req.params;
    requireString(req, req.params, 'code');
    try {
        const { boc, hash } = nekoton.codeToTvc(code);
        return { tvc: boc, hash };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const mergeTvc = async (_ctx, req) => {
    requireParams(req);
    const { code, data } = req.params;
    requireString(req, req.params, 'code');
    requireString(req, req.params, 'data');
    try {
        const { boc, hash } = nekoton.mergeTvc(code, data);
        return { tvc: boc, hash };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const splitTvc = async (_ctx, req) => {
    requireParams(req);
    const { tvc } = req.params;
    requireString(req, req.params, 'tvc');
    try {
        return nekoton.splitTvc(tvc);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const setCodeSalt = async (_ctx, req) => {
    requireParams(req);
    const { code, salt } = req.params;
    requireString(req, req.params, 'code');
    requireString(req, req.params, 'salt');
    try {
        const { boc, hash } = nekoton.setCodeSalt(code, salt);
        return { code: boc, hash };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const getCodeSalt = async (_ctx, req) => {
    requireParams(req);
    const { code } = req.params;
    requireString(req, req.params, 'code');
    try {
        return { salt: nekoton.getCodeSalt(code) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const encodeInternalInput = async (_ctx, req) => {
    requireParams(req);
    requireFunctionCall(req, req, 'params');
    const { abi, method, params } = req.params;
    try {
        return { boc: nekoton.encodeInternalInput(abi, method, params) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const decodeInput = async (_ctx, req) => {
    requireParams(req);
    const { body, abi, method, internal } = req.params;
    requireString(req, req.params, 'body');
    requireString(req, req.params, 'abi');
    requireMethodOrArray(req, req.params, 'method');
    requireBoolean(req, req.params, 'internal');
    try {
        return nekoton.decodeInput(body, abi, method, internal) || null;
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const decodeOutput = async (_ctx, req) => {
    requireParams(req);
    const { body, abi, method } = req.params;
    requireString(req, req.params, 'body');
    requireString(req, req.params, 'abi');
    requireMethodOrArray(req, req.params, 'method');
    try {
        return nekoton.decodeOutput(body, abi, method) || null;
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const decodeEvent = async (_ctx, req) => {
    requireParams(req);
    const { body, abi, event } = req.params;
    requireString(req, req.params, 'body');
    requireString(req, req.params, 'abi');
    requireMethodOrArray(req, req.params, 'event');
    try {
        return nekoton.decodeEvent(body, abi, event) || null;
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const decodeTransaction = async (_ctx, req) => {
    requireParams(req);
    const { transaction, abi, method } = req.params;
    requireString(req, req.params, 'abi');
    requireMethodOrArray(req, req.params, 'method');
    try {
        return nekoton.decodeTransaction(transaction, abi, method) || null;
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const decodeTransactionEvents = async (_ctx, req) => {
    requireParams(req);
    const { transaction, abi } = req.params;
    requireString(req, req.params, 'abi');
    try {
        return { events: nekoton.decodeTransactionEvents(transaction, abi) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const verifySignature = async (ctx, req) => {
    requireParams(req);
    const { publicKey, dataHash, signature, withSignatureId } = req.params;
    requireString(req, req.params, 'publicKey');
    requireString(req, req.params, 'dataHash');
    requireString(req, req.params, 'signature');
    requireOptionalSignatureId(req, req.params, 'withSignatureId');
    const signatureId = await computeSignatureId(req, ctx, withSignatureId);
    try {
        return { isValid: nekoton.verifySignature(publicKey, dataHash, signature, signatureId) };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const sendUnsignedExternalMessage = async (ctx, req) => {
    requireParams(req);
    requireConnection(req, ctx);
    const { recipient, stateInit, payload, local, executorParams } = req.params;
    requireString(req, req.params, 'recipient');
    requireOptionalString(req, req.params, 'stateInit');
    requireOptionalRawFunctionCall(req, req.params, 'payload');
    requireOptionalBoolean(req, req.params, 'local');
    requireOptionalObject(req, req.params, 'executorParams');
    let repackedRecipient;
    try {
        repackedRecipient = nekoton.repackAddress(recipient);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    const { clock, subscriptionController, properties } = ctx;
    const makeSignedMessage = (timeout) => {
        try {
            if (typeof payload === 'string' || payload == null) {
                const expireAt = ~~(clock.nowMs / 1000) + timeout;
                return nekoton.createRawExternalMessage(repackedRecipient, stateInit, payload, ~~expireAt);
            }
            else {
                return nekoton.createExternalMessageWithoutSignature(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, ~~timeout);
            }
        }
        catch (e) {
            throw invalidRequest(req, e.toString());
        }
    };
    const handleTransaction = (transaction) => {
        let output;
        try {
            if (typeof payload === 'object' && typeof payload != null) {
                const decoded = nekoton.decodeTransaction(transaction, payload.abi, payload.method);
                output = decoded === null || decoded === void 0 ? void 0 : decoded.output;
            }
        }
        catch (_) {
            /* do nothing */
        }
        return { transaction, output };
    };
    // Force local execution
    if (local === true) {
        const signedMessage = makeSignedMessage(60);
        const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage, executorParams);
        return handleTransaction(transaction);
    }
    // Send and wait with several retries
    let timeout = properties.message.timeout;
    for (let retry = 0; retry < properties.message.retryCount; ++retry) {
        const signedMessage = makeSignedMessage(timeout);
        const transaction = await subscriptionController.sendMessage(repackedRecipient, signedMessage);
        if (transaction == null) {
            timeout *= properties.message.timeoutGrowFactor;
            continue;
        }
        return handleTransaction(transaction);
    }
    // Execute locally
    const errorMessage = 'Message expired';
    const signedMessage = makeSignedMessage(60);
    const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage).catch(e => {
        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);
    });
    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';
    throw invalidRequest(req, `${errorMessage}${additionalText}`);
};
const signData = async (ctx, req) => {
    requireKeystore(req, ctx);
    requireParams(req);
    const { publicKey, data, withSignatureId } = req.params;
    requireString(req, req.params, 'publicKey');
    requireString(req, req.params, 'data');
    requireOptionalSignatureId(req, req.params, 'withSignatureId');
    const signatureId = await computeSignatureId(req, ctx, withSignatureId);
    const { keystore } = ctx;
    const signer = await keystore.getSigner(publicKey);
    if (signer == null) {
        throw invalidRequest(req, 'Signer not found for public key');
    }
    try {
        const dataHash = nekoton.getDataHash(data);
        return {
            dataHash,
            ...(await signer.sign(dataHash, signatureId).then(nekoton.extendSignature)),
        };
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const signDataRaw = async (ctx, req) => {
    requireKeystore(req, ctx);
    requireParams(req);
    const { publicKey, data, withSignatureId } = req.params;
    requireString(req, req.params, 'publicKey');
    requireString(req, req.params, 'data');
    requireOptionalSignatureId(req, req.params, 'withSignatureId');
    const signatureId = await computeSignatureId(req, ctx, withSignatureId);
    const { keystore } = ctx;
    const signer = await keystore.getSigner(publicKey);
    if (signer == null) {
        throw invalidRequest(req, 'Signer not found for public key');
    }
    try {
        return await signer.sign(data, signatureId).then(nekoton.extendSignature);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
};
const sendMessage = async (ctx, req) => {
    requireKeystore(req, ctx);
    requireAccountsStorage(req, ctx);
    requireConnection(req, ctx);
    requireParams(req);
    const { sender, recipient, amount, bounce, payload, stateInit } = req.params;
    requireString(req, req.params, 'sender');
    requireString(req, req.params, 'recipient');
    requireString(req, req.params, 'amount');
    requireBoolean(req, req.params, 'bounce');
    requireOptional(req, req.params, 'payload', requireFunctionCall);
    requireOptionalString(req, req.params, 'stateInit');
    const signatureId = await computeSignatureId(req, ctx);
    const { clock, properties, subscriptionController, connectionController, keystore, accountsStorage } = ctx;
    let repackedSender;
    let repackedRecipient;
    let account;
    try {
        repackedSender = nekoton.repackAddress(sender);
        repackedRecipient = nekoton.repackAddress(recipient);
        account = await accountsStorage.getAccount(repackedSender).then(account => {
            if (account != null) {
                return account;
            }
            else {
                throw new Error('Sender not found');
            }
        });
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    const makeSignedMessage = async (timeout) => {
        try {
            return account.prepareMessage({
                recipient: repackedRecipient,
                amount,
                bounce,
                payload,
                stateInit,
                timeout: ~~timeout,
                signatureId,
            }, new AccountsStorage_1.AccountsStorageContext(clock, connectionController, nekoton, keystore));
        }
        catch (e) {
            throw invalidRequest(req, e.toString());
        }
    };
    // Send and wait with several retries
    let timeout = properties.message.timeout;
    // Set `retryCount` if not explicitly disabled
    const retryCount = properties.message.retryTransfers !== false ? properties.message.retryCount : 1;
    for (let retry = 0; retry < retryCount; ++retry) {
        const signedMessage = await makeSignedMessage(timeout);
        const transaction = await subscriptionController.sendMessage(repackedSender, signedMessage);
        if (transaction == null) {
            timeout *= properties.message.timeoutGrowFactor;
            continue;
        }
        return { transaction };
    }
    // Execute locally
    const errorMessage = 'Message expired';
    const signedMessage = await makeSignedMessage(60);
    const transaction = await subscriptionController.sendMessageLocally(repackedSender, signedMessage).catch(e => {
        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);
    });
    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';
    throw invalidRequest(req, `${errorMessage}${additionalText}`);
};
const sendMessageDelayed = async (ctx, req) => {
    requireKeystore(req, ctx);
    requireAccountsStorage(req, ctx);
    requireParams(req);
    requireConnection(req, ctx);
    const { sender, recipient, amount, bounce, payload, stateInit } = req.params;
    requireString(req, req.params, 'sender');
    requireString(req, req.params, 'recipient');
    requireString(req, req.params, 'amount');
    requireBoolean(req, req.params, 'bounce');
    requireOptional(req, req.params, 'payload', requireFunctionCall);
    requireOptionalString(req, req.params, 'stateInit');
    const signatureId = await computeSignatureId(req, ctx);
    const { clock, subscriptionController, connectionController, keystore, accountsStorage, notify } = ctx;
    let repackedSender;
    let repackedRecipient;
    try {
        repackedSender = nekoton.repackAddress(sender);
        repackedRecipient = nekoton.repackAddress(recipient);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    let signedMessage;
    try {
        const account = await accountsStorage.getAccount(repackedSender);
        if (account == null) {
            throw new Error('Sender not found');
        }
        signedMessage = await account.prepareMessage({
            recipient: repackedRecipient,
            amount,
            bounce,
            payload,
            stateInit,
            timeout: 60,
            signatureId,
        }, new AccountsStorage_1.AccountsStorageContext(clock, connectionController, nekoton, keystore));
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    subscriptionController
        .sendMessage(repackedSender, signedMessage)
        .then(transaction => {
        notify('messageStatusUpdated', {
            address: repackedSender,
            hash: signedMessage.hash,
            transaction,
        });
    })
        .catch(console.error);
    return {
        message: {
            account: repackedSender,
            hash: signedMessage.hash,
            expireAt: signedMessage.expireAt,
        },
    };
};
const sendExternalMessage = async (ctx, req) => {
    requireKeystore(req, ctx);
    requireParams(req);
    requireConnection(req, ctx);
    const { publicKey, recipient, stateInit, payload, local, executorParams } = req.params;
    requireString(req, req.params, 'publicKey');
    requireString(req, req.params, 'recipient');
    requireOptionalString(req, req.params, 'stateInit');
    requireFunctionCall(req, req.params, 'payload');
    requireOptionalBoolean(req, req.params, 'local');
    requireOptionalObject(req, req.params, 'executorParams');
    const signatureId = await computeSignatureId(req, ctx);
    let repackedRecipient;
    try {
        repackedRecipient = nekoton.repackAddress(recipient);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    const { clock, subscriptionController, keystore, properties } = ctx;
    const signer = await keystore.getSigner(publicKey);
    if (signer == null) {
        throw invalidRequest(req, 'Signer not found for public key');
    }
    const makeSignedMessage = async (timeout) => {
        let unsignedMessage;
        try {
            unsignedMessage = nekoton.createExternalMessage(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, publicKey, ~~timeout);
        }
        catch (e) {
            throw invalidRequest(req, e.toString());
        }
        try {
            const signature = await signer.sign(unsignedMessage.hash, signatureId);
            return unsignedMessage.sign(signature);
        }
        catch (e) {
            throw invalidRequest(req, e.toString());
        }
        finally {
            unsignedMessage.free();
        }
    };
    const handleTransaction = (transaction) => {
        let output;
        try {
            const decoded = nekoton.decodeTransaction(transaction, payload.abi, payload.method);
            output = decoded === null || decoded === void 0 ? void 0 : decoded.output;
        }
        catch (_) {
            /* do nothing */
        }
        return { transaction, output };
    };
    // Force local execution
    if (local === true) {
        const signedMessage = await makeSignedMessage(60);
        const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage, executorParams);
        return handleTransaction(transaction);
    }
    // Send and wait with several retries
    let timeout = properties.message.timeout;
    for (let retry = 0; retry < properties.message.retryCount; ++retry) {
        const signedMessage = await makeSignedMessage(timeout);
        const transaction = await subscriptionController.sendMessage(repackedRecipient, signedMessage);
        if (transaction == null) {
            timeout *= properties.message.timeoutGrowFactor;
            continue;
        }
        return handleTransaction(transaction);
    }
    // Execute locally
    const errorMessage = 'Message expired';
    const signedMessage = await makeSignedMessage(60);
    const transaction = await subscriptionController.sendMessageLocally(repackedRecipient, signedMessage).catch(e => {
        throw invalidRequest(req, `${errorMessage}. ${e.toString()}`);
    });
    const additionalText = transaction.exitCode != null ? `. Possible exit code: ${transaction.exitCode}` : '';
    throw invalidRequest(req, `${errorMessage}${additionalText}`);
};
const sendExternalMessageDelayed = async (ctx, req) => {
    requireKeystore(req, ctx);
    requireParams(req);
    requireConnection(req, ctx);
    const { publicKey, recipient, stateInit, payload } = req.params;
    requireString(req, req.params, 'publicKey');
    requireString(req, req.params, 'recipient');
    requireOptionalString(req, req.params, 'stateInit');
    requireFunctionCall(req, req.params, 'payload');
    const signatureId = await computeSignatureId(req, ctx);
    let repackedRecipient;
    try {
        repackedRecipient = nekoton.repackAddress(recipient);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    const { clock, subscriptionController, keystore, properties, notify } = ctx;
    const signer = await keystore.getSigner(publicKey);
    if (signer == null) {
        throw invalidRequest(req, 'Signer not found for public key');
    }
    let unsignedMessage;
    try {
        unsignedMessage = nekoton.createExternalMessage(clock, repackedRecipient, payload.abi, payload.method, stateInit, payload.params, publicKey, ~~properties.message.timeout);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    let signedMessage;
    try {
        const signature = await signer.sign(unsignedMessage.hash, signatureId);
        signedMessage = unsignedMessage.sign(signature);
    }
    catch (e) {
        throw invalidRequest(req, e.toString());
    }
    finally {
        unsignedMessage.free();
    }
    subscriptionController
        .sendMessage(repackedRecipient, signedMessage)
        .then(transaction => {
        notify('messageStatusUpdated', {
            address: repackedRecipient,
            hash: signedMessage.hash,
            transaction,
        });
    })
        .catch(console.error);
    return {
        message: {
            account: repackedRecipient,
            hash: signedMessage.hash,
            expireAt: signedMessage.expireAt,
        },
    };
};
function requireKeystore(req, context) {
    if (context.keystore == null) {
        throw invalidRequest(req, 'Keystore not found');
    }
}
function requireAccountsStorage(req, context) {
    if (context.accountsStorage == null) {
        throw invalidRequest(req, 'AccountsStorage not found');
    }
}
function requireConnection(req, context) {
    if (context.connectionController == null || context.subscriptionController == null) {
        throw invalidRequest(req, 'Connection was not initialized');
    }
}
async function computeSignatureId(req, ctx, withSignatureId) {
    if (withSignatureId === false) {
        return undefined;
    }
    else if (typeof withSignatureId === 'number') {
        return withSignatureId;
    }
    else if (ctx.connectionController == null) {
        return undefined;
    }
    return ctx.connectionController
        .use(async ({ data: { transport } }) => transport.getSignatureId())
        .catch(_ => {
        throw invalidRequest(req, 'Failed to fetch signature id');
    });
}
function requireParams(req) {
    if (req.params == null || typeof req.params !== 'object') {
        throw invalidRequest(req, 'required params object');
    }
}
function requireObject(req, object, key) {
    const property = object[key];
    if (typeof property !== 'object') {
        throw invalidRequest(req, `'${String(key)}' must be an object`);
    }
}
function requireOptionalObject(req, object, key) {
    const property = object[key];
    if (property != null && typeof property !== 'object') {
        throw invalidRequest(req, `'${String(key)}' must be an object if specified`);
    }
}
function requireBoolean(req, object, key) {
    const property = object[key];
    if (typeof property !== 'boolean') {
        throw invalidRequest(req, `'${String(key)}' must be a boolean`);
    }
}
function requireOptionalBoolean(req, object, key) {
    const property = object[key];
    if (property != null && typeof property !== 'boolean') {
        throw invalidRequest(req, `'${String(key)}' must be a boolean if specified`);
    }
}
function requireString(req, object, key) {
    const property = object[key];
    if (typeof property !== 'string' || property.length === 0) {
        throw invalidRequest(req, `'${String(key)}' must be non-empty string`);
    }
}
function requireOptionalString(req, object, key) {
    const property = object[key];
    if (property != null && (typeof property !== 'string' || property.length === 0)) {
        throw invalidRequest(req, `'${String(key)}' must be a non-empty string if provided`);
    }
}
function requireOptionalNumber(req, object, key) {
    const property = object[key];
    if (property != null && typeof property !== 'number') {
        throw invalidRequest(req, `'${String(key)}' must be a number if provider`);
    }
}
function requireArray(req, object, key) {
    const property = object[key];
    if (!Array.isArray(property)) {
        throw invalidRequest(req, `'${String(key)}' must be an array`);
    }
}
function requireOptional(req, object, key, predicate) {
    const property = object[key];
    if (property != null) {
        predicate(req, object, key);
    }
}
function requireOptionalSignatureId(req, object, key) {
    const property = object[key];
    if (property != null) {
        if (typeof property !== 'boolean' && typeof property !== 'number') {
            throw invalidRequest(req, `'${String(key)}' must be an optional boolean or number`);
        }
    }
}
function requireTransactionId(req, object, key) {
    requireObject(req, object, key);
    const property = object[key];
    requireString(req, property, 'lt');
    requireString(req, property, 'hash');
}
function requireLastTransactionId(req, object, key) {
    requireObject(req, object, key);
    const property = object[key];
    requireBoolean(req, property, 'isExact');
    requireString(req, property, 'lt');
    requireOptionalString(req, property, 'hash');
}
function requireContractState(req, object, key) {
    requireObject(req, object, key);
    const property = object[key];
    requireString(req, property, 'balance');
    requireOptional(req, property, 'lastTransactionId', requireLastTransactionId);
    requireBoolean(req, property, 'isDeployed');
}
function requireFunctionCall(req, object, key) {
    requireObject(req, object, key);
    const property = object[key];
    requireString(req, property, 'abi');
    requireString(req, property, 'method');
    requireObject(req, property, 'params');
}
function requireOptionalRawFunctionCall(req, object, key) {
    const property = object[key];
    if (typeof property === 'string' || property == null) {
        return;
    }
    else if (typeof property === 'object') {
        requireString(req, property, 'abi');
        requireString(req, property, 'method');
        requireObject(req, property, 'params');
    }
    else {
        throw invalidRequest(req, `'${String(key)}' must be a function all or optional string`);
    }
}
function requireMethodOrArray(req, object, key) {
    const property = object[key];
    if (property != null && typeof property !== 'string' && !Array.isArray(property)) {
        throw invalidRequest(req, `'${String(key)}' must be a method name or an array of possible names`);
    }
}
async function makeAccountInteractionPermission(req, ctx) {
    requireAccountsStorage(req, ctx);
    requireConnection(req, ctx);
    const defaultAccount = ctx.accountsStorage.defaultAccount;
    if (defaultAccount == null) {
        throw invalidRequest(req, 'Default account not set in accounts storage');
    }
    const account = await ctx.accountsStorage.getAccount(defaultAccount);
    if (account == null) {
        throw invalidRequest(req, 'Default account not found');
    }
    const publicKey = await account.fetchPublicKey(new AccountsStorage_1.AccountsStorageContext(ctx.clock, ctx.connectionController, nekoton));
    return {
        address: account.address.toString(),
        publicKey,
        contractType: 'unknown',
    };
}
const invalidRequest = (req, message, data) => new NekotonRpcError(2, `${req.method}: ${message}`, data);
class NekotonRpcError extends Error {
    constructor(code, message, data) {
        if (!Number.isInteger(code)) {
            throw new Error('"code" must be an integer');
        }
        if (!message || typeof message !== 'string') {
            throw new Error('"message" must be a nonempty string');
        }
        super(message);
        this.code = code;
        this.data = data;
    }
    serialize() {
        const serialized = {
            code: this.code,
            message: this.message,
        };
        if (this.data !== undefined) {
            serialized.data = this.data;
        }
        if (this.stack) {
            serialized.stack = this.stack;
        }
        return serialized;
    }
    toString() {
        return (0, fast_safe_stringify_1.default)(this.serialize(), stringifyReplacer, 2);
    }
}
const stringifyReplacer = (_, value) => {
    if (value === '[Circular]') {
        return undefined;
    }
    return value;
};
