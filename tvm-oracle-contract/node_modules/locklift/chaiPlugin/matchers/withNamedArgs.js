"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.supportWithNamedArgs = void 0;
const utils_1 = require("../utils");
const lodash_1 = __importDefault(require("lodash"));
/**
 * Used for testing the arguments of events or custom errors, naming the arguments.
 * Can test the subset of all arguments.
 * Should be used after .emit or .call matcher.
 */
function supportWithNamedArgs(Assertion, utils) {
    Assertion.addMethod("withNamedArgs", function (expectedArgs, message) {
        const events = utils.flag(this, "messages");
        const expectedArgsWithUpdatedAddress = (0, utils_1.mapAddressesToString)(expectedArgs);
        const matchedEvent = events
            .map(({ decodedMsg }) => {
            if (!decodedMsg?.params) {
                throw new Error(`Event ${decodedMsg?.method} doesn't have params`);
            }
            const eventParamsWithUpdatedAddress = (0, utils_1.mapAddressesToString)(decodedMsg.params);
            return (0, utils_1.objectIntersection)(eventParamsWithUpdatedAddress, expectedArgsWithUpdatedAddress);
        })
            .find(partialEventArgs => {
            return lodash_1.default.isEqual(partialEventArgs, expectedArgsWithUpdatedAddress);
        });
        if (matchedEvent) {
            new Assertion(matchedEvent).to.be.deep.equal(expectedArgsWithUpdatedAddress, message);
        }
        else {
            const firstEvent = events[0];
            if (!firstEvent.decodedMsg?.params) {
                throw new Error(`Event ${firstEvent.decodedMsg?.method} doesn't have params`);
            }
            const { eventParamsWithUpdatedAddress } = {
                eventParamsWithUpdatedAddress: (0, utils_1.mapAddressesToString)(firstEvent.decodedMsg.params),
            };
            const partialEventArgs = (0, utils_1.objectIntersection)(eventParamsWithUpdatedAddress, expectedArgsWithUpdatedAddress);
            new Assertion(partialEventArgs).to.be.deep.equal(expectedArgsWithUpdatedAddress, message);
        }
        return this;
    });
}
exports.supportWithNamedArgs = supportWithNamedArgs;
