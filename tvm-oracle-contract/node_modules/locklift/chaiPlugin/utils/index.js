"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.objectIntersection = exports.mapAddressesToString = exports.getMessage = void 0;
const everscale_inpage_provider_1 = require("everscale-inpage-provider");
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("../../internal/tracing/utils");
const getMessage = ({ viewTracingTree, contract, msgType, msgName, }) => {
    return viewTracingTree
        .findByTypeWithFullData({ type: msgType, name: msgName })
        .filter(event => event.decodedMsg?.method === msgName)
        .filter(event => {
        if (!contract) {
            return true;
        }
        return contract instanceof everscale_inpage_provider_1.Address
            ? event.contract.contract.address.equals(contract)
            : (0, utils_1.extractAddress)(contract).equals(event.contract.contract.address);
    });
};
exports.getMessage = getMessage;
const mapAddressesToString = (obj) => {
    const mapFn = (value) => {
        if (Array.isArray(value)) {
            return (0, exports.mapAddressesToString)(value);
        }
        if (value instanceof everscale_inpage_provider_1.Address) {
            return value.toString();
        }
        if (typeof value === "object") {
            return (0, exports.mapAddressesToString)(value);
        }
        return value;
    };
    if (Array.isArray(obj)) {
        return obj.map(mapFn);
    }
    return (0, lodash_1.default)(obj).mapValues(mapFn).value();
};
exports.mapAddressesToString = mapAddressesToString;
const objectIntersection = (rootObject, partialObject) => {
    if (!rootObject || !partialObject) {
        return rootObject;
    }
    if (Array.isArray(rootObject) && Array.isArray(partialObject)) {
        return rootObject
            .filter((_, idx) => !!partialObject[idx])
            .map((value, idx) => (typeof value === "object" ? (0, exports.objectIntersection)(value, partialObject[idx]) : value));
    }
    if (!Array.isArray(rootObject) && !Array.isArray(partialObject)) {
        return Object.entries(rootObject).reduce((acc, [key, value]) => key in partialObject
            ? {
                ...acc,
                [key]: typeof value === "object" ? (0, exports.objectIntersection)(value, partialObject[key]) : value,
            }
            : acc, {});
    }
    return rootObject;
};
exports.objectIntersection = objectIntersection;
