"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountFactory2 = void 0;
const types_1 = require("../../types");
const nodejs_1 = require("everscale-standalone-client/nodejs");
const utils_1 = require("./utils");
/*
AccountFactory2 is service based on everscale-standalone-client SimpleAccountsStorage
 */
class AccountFactory2 {
    sourceFactory;
    sender;
    accountsStorage;
    constructor(sourceFactory, sender, accountsStorage) {
        this.sourceFactory = sourceFactory;
        this.sender = sender;
        this.accountsStorage = accountsStorage;
    }
    /*
     * Deploy and add the account to the account storage
     */
    addNewAccount = async (params) => {
        const { account, tx } = await this.createAccount(params);
        this.accountsStorage.addAccount(account);
        return { account, tx };
    };
    createAccount = async (params) => {
        switch (params.type) {
            case types_1.WalletTypes.WalletV3: {
                const account = await nodejs_1.WalletV3Account.fromPubkey({ publicKey: params.publicKey });
                const depositTransaction = await this.sender(account.address, params.value);
                return {
                    account,
                    tx: depositTransaction,
                };
            }
            case types_1.WalletTypes.HighLoadWalletV2: {
                const account = await nodejs_1.HighloadWalletV2.fromPubkey({ publicKey: params.publicKey });
                const depositTransaction = await this.sender(account.address, params.value);
                return {
                    account,
                    tx: depositTransaction,
                };
            }
            case types_1.WalletTypes.MsigAccount: {
                const { abi } = this.sourceFactory.getContractArtifacts(params.contract);
                (0, utils_1.validateAccountAbi)(abi);
                const contractWithTx = await this.sourceFactory.deployContract(params);
                const account = new nodejs_1.MsigAccount({
                    publicKey: params.publicKey,
                    address: contractWithTx.contract.address,
                    type: params.mSigType,
                });
                return { tx: contractWithTx.tx, account };
            }
            case types_1.WalletTypes.EverWallet: {
                const account = await nodejs_1.EverWalletAccount.fromPubkey({ publicKey: params.publicKey, nonce: params.nonce });
                const depositTransaction = await this.sender(account.address, params.value);
                return {
                    account,
                    tx: depositTransaction,
                };
            }
        }
    };
    /*
     * Add an existing account to the account storage
     */
    addExistingAccount = async (params) => {
        const account = await this.getExistingAccount(params);
        this.accountsStorage.addAccount(account);
        return account;
    };
    getExistingAccount = async (params) => {
        switch (params.type) {
            case types_1.WalletTypes.HighLoadWalletV2:
                return nodejs_1.HighloadWalletV2.fromPubkey({ publicKey: params.publicKey });
            case types_1.WalletTypes.WalletV3:
                return nodejs_1.WalletV3Account.fromPubkey({ publicKey: params.publicKey });
            case types_1.WalletTypes.MsigAccount:
                return new nodejs_1.MsigAccount({ publicKey: params.publicKey, address: params.address, type: params.mSigType });
            case types_1.WalletTypes.EverWallet:
                return new nodejs_1.EverWalletAccount(params.address);
        }
    };
    /*
    Access to the account storage
     */
    get storage() {
        return this.accountsStorage;
    }
}
exports.AccountFactory2 = AccountFactory2;
