"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGiver = void 0;
const everscale_inpage_provider_1 = require("everscale-inpage-provider");
const nodejs_1 = require("everscale-standalone-client/nodejs");
const utils_1 = require("./utils");
const giverOptions_1 = require("./giverOptions");
const constants_1 = require("./constants");
const utils_2 = require("../../utils");
const logger_1 = require("../logger");
const logGiverFactory = (giverBalance) => (walletName) => logger_1.logger.printInfo(`${walletName} is used as a giver, the giver balance is: ${giverBalance} ever`);
const getGiver = async (giverConfig, provider, accountStorage) => {
    const giverKeyPair = (0, utils_1.getGiverKeyPair)(giverConfig);
    if (giverConfig.giverFactory) {
        return giverConfig.giverFactory(provider, giverKeyPair, giverConfig.address);
    }
    const giverAddress = new everscale_inpage_provider_1.Address(giverConfig.address);
    const giverState = await provider
        .getFullContractState({
        address: giverAddress,
    })
        .then(res => res.state);
    if (!giverState) {
        throw new Error("Giver has empty contract state, check the giver address");
    }
    const logGiver = logGiverFactory((0, utils_2.fromNano)(giverState.balance));
    if (!giverState.isDeployed) {
        const wallets = [
            { wallet: nodejs_1.WalletV3Account, walletName: "WalletV3" },
            { wallet: nodejs_1.EverWalletAccount, walletName: "EverWallet" },
            { wallet: nodejs_1.HighloadWalletV2, walletName: "HighloadWalletV2" },
        ];
        for (const { wallet, walletName } of wallets) {
            if (await wallet
                .computeAddress({
                publicKey: giverKeyPair.publicKey,
            })
                .then(res => res.equals(giverAddress))) {
                accountStorage.addAccount(await wallet.fromPubkey({
                    publicKey: giverKeyPair.publicKey,
                }));
                logGiver(walletName);
                return new giverOptions_1.GiverFromAccount(provider, giverAddress);
            }
        }
        throw new Error("Public key doesn't match by WalletV3, EverWallet, HighloadWalletV2 addresses");
    }
    const giverType = Object.entries(constants_1.GiverTypes).find(([, codeHash]) => codeHash === giverState.codeHash)?.[1];
    if (!giverType) {
        throw new Error("Introduced giver doesn't match by known givers");
    }
    switch (giverType) {
        case constants_1.GiverTypes.MainGiver:
            logGiver("MainGiver");
            return new giverOptions_1.TestnetGiver(provider, giverKeyPair, giverAddress);
        case constants_1.GiverTypes.WalletV3:
            logGiver("WalletV3");
            accountStorage.addAccount(new nodejs_1.WalletV3Account(giverAddress));
            return new giverOptions_1.GiverFromAccount(provider, giverAddress);
        case constants_1.GiverTypes.EverWallet:
            logGiver("EverWallet");
            accountStorage.addAccount(new nodejs_1.EverWalletAccount(giverAddress));
            return new giverOptions_1.GiverFromAccount(provider, giverAddress);
        case constants_1.GiverTypes.HighloadWalletV2:
            logGiver("HighloadWalletV2");
            accountStorage.addAccount(new nodejs_1.HighloadWalletV2(giverAddress));
            return new giverOptions_1.GiverFromAccount(provider, giverAddress);
        case constants_1.GiverTypes.SafeMultisig:
        case constants_1.GiverTypes.SurfWallet:
        case constants_1.GiverTypes.SafeMultisig24:
        case constants_1.GiverTypes.SetCodeMultisig:
        case constants_1.GiverTypes.BridgeMultisig:
            logGiver("SafeMultisig");
            accountStorage.addAccount(new nodejs_1.MsigAccount({
                publicKey: giverKeyPair.publicKey,
                address: giverAddress,
                type: "SafeMultisig",
            }));
            return new giverOptions_1.GiverFromAccount(provider, giverAddress);
        case constants_1.GiverTypes.Multisig_2_1:
            logGiver("multisig2");
            accountStorage.addAccount(new nodejs_1.MsigAccount({
                publicKey: giverKeyPair.publicKey,
                address: giverAddress,
                type: "multisig2",
            }));
            return new giverOptions_1.GiverFromAccount(provider, giverAddress);
        case constants_1.GiverTypes.GiverV3:
        case constants_1.GiverTypes.GiverV2: {
            logGiver("GiverV2");
            accountStorage.addAccount(new nodejs_1.GiverAccount({
                publicKey: giverKeyPair.publicKey,
                address: giverAddress,
            }));
            return new giverOptions_1.GiverFromAccount(provider, giverAddress);
        }
    }
};
exports.getGiver = getGiver;
