"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTimeMovement = exports.TimeMovement = void 0;
const logger_1 = require("../logger");
const seService_1 = require("./seService");
class TimeMovement {
    seService;
    clock;
    isEnabled;
    constructor(seService, clock, isEnabled) {
        this.seService = seService;
        this.clock = clock;
        this.isEnabled = isEnabled;
    }
    /*
     * Returns current offset in seconds
     */
    getTimeOffset = () => {
        if (!this.isEnabled) {
            logger_1.logger.printWarn("TimeMovement is disabled");
            return 0;
        }
        return toSeconds(this.clock.offset);
    };
    /*
     * Returns current time
     */
    getCurrentTime = () => this.clock.time;
    /*
     * Set node and provider offset in seconds
     @param offsetInSeconds offset in seconds
     */
    increaseTime = async (seconds) => {
        if (!this.isEnabled) {
            return logger_1.logger.printWarn("TimeMovement is disabled");
        }
        if (seconds < 0) {
            return logger_1.logger.printWarn("TimeMovement is not allowed to go back in time");
        }
        this.clock.offset = await this.seService.setTimeOffset(seconds).then(toMs);
    };
    //TODO make it public when it will be resolved
    resetTimeOffset = async () => {
        if (!this.isEnabled) {
            return logger_1.logger.printWarn("TimeMovement is disabled");
        }
        this.clock.offset = await this.seService.resetTimeOffset().then(toMs);
        console.log(`TimeMovement reset to ${this.getTimeOffset()}`);
    };
}
exports.TimeMovement = TimeMovement;
const createTimeMovement = async (clock, connectionConfig) => {
    const rpcUrl = typeof connectionConfig.connection !== "string" &&
        connectionConfig.connection.type === "graphql" &&
        connectionConfig.connection.data.endpoints[0];
    if (!rpcUrl) {
        return new TimeMovement(new seService_1.SeService(""), clock, false);
    }
    const rpcOrigin = new URL(rpcUrl).origin;
    const seService = new seService_1.SeService(rpcOrigin);
    const { currentOffsetInSeconds, isEnabled } = await seService
        .getCurrentOffsetTime()
        .then(currentOffsetInSeconds => ({ currentOffsetInSeconds, isEnabled: true }))
        .catch(() => ({ isEnabled: false, currentOffsetInSeconds: 0 }));
    if (currentOffsetInSeconds > 0) {
        logger_1.logger.printWarn(`Current SE time delta is ${currentOffsetInSeconds} seconds. Provider will sync with this offset`);
    }
    clock.offset = toMs(currentOffsetInSeconds);
    return new TimeMovement(seService, clock, isEnabled);
};
exports.createTimeMovement = createTimeMovement;
const toMs = (seconds) => seconds * 1000;
const toSeconds = (ms) => ms / 1000;
