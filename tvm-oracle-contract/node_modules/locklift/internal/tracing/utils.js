"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractAddress = exports.extractStringAddress = exports.isExistsInArr = exports.getDefaultAllowedCodes = exports.isT = exports.throwErrorInConsole = exports.hexToValue = exports.convertForLogger = exports.convert = exports.fetchAccounts = exports.fetchMsgData = void 0;
const types_1 = require("./types");
const logger_1 = require("../logger");
const httpService_1 = require("../httpService");
const everscale_inpage_provider_1 = require("everscale-inpage-provider");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const fetchMsgData = async (msgId, endpoint) => {
    const msgQuery = `{
    messages(
      timeout: 1000,
      filter: {
        id: {
          eq: "${msgId}"
        }
      }
    ) {
      id
      body
      code_hash
      src
      msg_type
      dst
      dst_account {
        id
        code_hash
      }
      src_account{
        id
        code_hash
      }
      dst_transaction {
        status
        total_fees
        aborted
        out_msgs
        storage {
          storage_fees_collected
        }
        compute {
          exit_code
          compute_type
          success
          gas_fees
        }
        action {
          result_code
          success
          total_action_fees
          total_fwd_fees
        }
      }
      status
      value
      bounced
      bounce
    }
  }`;
    const response = await httpService_1.httpService
        .post(endpoint, { query: msgQuery })
        .then(res => res.data.data);
    return response.messages[0];
};
exports.fetchMsgData = fetchMsgData;
const fetchAccounts = async (accounts, endpoint) => {
    const msgQuery = `{
  accounts(
    filter: {
      id: {
        in: ${JSON.stringify(accounts.map(account => account.toString()))}
      }
    }
  ) {
    code_hash
    id
  }
}`;
    const response = await httpService_1.httpService
        .post(endpoint, { query: msgQuery })
        .then(res => res.data.data);
    return response.accounts;
};
exports.fetchAccounts = fetchAccounts;
const convert = (number, decimals = 9, precision = 4) => {
    if (number === null) {
        return null;
    }
    return (number / 10 ** decimals).toPrecision(precision);
};
exports.convert = convert;
const convertForLogger = (amount) => new bignumber_js_1.default((0, exports.convert)(amount, 9, 8) || 0);
exports.convertForLogger = convertForLogger;
const hexToValue = (amount) => new bignumber_js_1.default((0, exports.convert)(amount, 9, 9) || 0);
exports.hexToValue = hexToValue;
const throwErrorInConsole = (revertedBranch) => {
    for (const { totalActions, actionIdx, traceLog } of revertedBranch) {
        const bounce = traceLog.msg.bounce;
        let name = "undefinedContract";
        if (traceLog.contract) {
            name = traceLog.contract.name;
        }
        let method = "undefinedMethod";
        if (traceLog.decodedMsg?.method) {
            method = traceLog.decodedMsg.method;
        }
        else if (traceLog.type === types_1.TraceType.BOUNCE) {
            method = "onBounce";
        }
        let paramsStr = "()";
        if (traceLog.decodedMsg) {
            if (Object.values(traceLog.decodedMsg.params || {}).length === 0) {
                paramsStr = "()";
            }
            else {
                paramsStr = "(\n";
                for (const [key, value] of Object.entries(traceLog.decodedMsg.params || {})) {
                    paramsStr += `    ${key}: ${JSON.stringify(value, null, 4)}\n`;
                }
                paramsStr += ")";
            }
        }
        logger_1.logger.printTracingLog("\t\t⬇\n\t\t⬇");
        logger_1.logger.printTracingLog(`\t#${actionIdx + 1} action out of ${totalActions}`);
        // green tags
        logger_1.logger.printTracingLog(`Addr: \x1b[32m${traceLog.msg.dst}\x1b[0m`);
        logger_1.logger.printTracingLog(`MsgId: \x1b[32m${traceLog.msg.id}\x1b[0m`);
        logger_1.logger.printTracingLog("-----------------------------------------------------------------");
        if (traceLog.type === types_1.TraceType.BOUNCE) {
            logger_1.logger.printTracingLog("-> Bounced msg");
        }
        if (traceLog.error && traceLog.error.ignored) {
            logger_1.logger.printTracingLog(`-> Ignored ${traceLog.error.code} code on ${traceLog.error.phase} phase`);
        }
        if (!traceLog.contract) {
            logger_1.logger.printTracingLog("-> Contract not deployed/Not recognized because build artifacts not provided");
        }
        // bold tag
        logger_1.logger.printTracingLog(`\x1b[1m${name}.${method}\x1b[22m{value: ${(0, exports.convert)(traceLog.msg.value)}, bounce: ${bounce}}${paramsStr}`);
        if (traceLog.msg.dst_transaction) {
            if (traceLog.msg.dst_transaction.storage) {
                logger_1.logger.printTracingLog(`Storage fees: ${(0, exports.convert)(traceLog.msg.dst_transaction.storage.storage_fees_collected)}`);
            }
            if (traceLog.msg.dst_transaction.compute) {
                logger_1.logger.printTracingLog(`Compute fees: ${(0, exports.convert)(Number(traceLog.msg.dst_transaction.compute.gas_fees))}`);
            }
            if (traceLog.msg.dst_transaction.action) {
                logger_1.logger.printTracingLog(`Action fees: ${(0, exports.convert)(Number(traceLog.msg.dst_transaction.action.total_action_fees))}`);
            }
            logger_1.logger.printTracingLog(`\x1b[1mTotal fees:\x1b[22m ${(0, exports.convert)(Number(traceLog.msg.dst_transaction.total_fees))}`);
        }
        if (traceLog.error && !traceLog.error.ignored) {
            // red tag
            logger_1.logger.printError("\x1b[31m", `!!! Reverted with ${traceLog.error.code} error code on ${traceLog.error.phase} phase !!!`);
            throw new Error(`Reverted with ${traceLog.error.code} code on ${traceLog.error.phase} phase`);
        }
    }
};
exports.throwErrorInConsole = throwErrorInConsole;
const isT = (p) => !!p;
exports.isT = isT;
const getDefaultAllowedCodes = () => ({
    compute: [],
    action: [],
});
exports.getDefaultAllowedCodes = getDefaultAllowedCodes;
const isExistsInArr = (srcArr, isExist) => {
    return srcArr.some(item => item === isExist);
};
exports.isExistsInArr = isExistsInArr;
const extractStringAddress = (contract) => typeof contract === "string"
    ? contract
    : contract instanceof everscale_inpage_provider_1.Address
        ? contract.toString()
        : contract.address.toString();
exports.extractStringAddress = extractStringAddress;
const extractAddress = (contract) => new everscale_inpage_provider_1.Address((0, exports.extractStringAddress)(contract));
exports.extractAddress = extractAddress;
