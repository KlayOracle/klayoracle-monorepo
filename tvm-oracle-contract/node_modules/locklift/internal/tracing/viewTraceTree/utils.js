"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDesiredMethod = exports.getErrorsInfo = exports.getBalanceDiff = exports.getBalanceChangingInfo = exports.printer = exports.calculateTotalFees = exports.applyTotalFees = exports.colors = exports.mapType = void 0;
const types_1 = require("../types");
const chalk_1 = __importDefault(require("chalk"));
const utils_1 = require("../utils");
const mappers_1 = require("./mappers");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const lodash_1 = __importDefault(require("lodash"));
exports.mapType = {
    [types_1.TraceType.BOUNCE]: "BONCE",
    [types_1.TraceType.DEPLOY]: "DEPLOY",
    [types_1.TraceType.EVENT]: "EVENT",
    [types_1.TraceType.EVENT_OR_FUNCTION_RETURN]: "EVENT_OR_RETURN",
    [types_1.TraceType.FUNCTION_CALL]: "CALL",
    [types_1.TraceType.FUNCTION_RETURN]: "RETURN",
    [types_1.TraceType.TRANSFER]: "TRANSFER",
};
exports.colors = {
    contractName: chalk_1.default.cyan,
    methodName: chalk_1.default.blueBright,
    paramsKey: chalk_1.default.magenta,
    error: chalk_1.default.red,
};
const applyTotalFees = (viewTrace) => {
    return {
        ...viewTrace,
        ...(0, mappers_1.extractFeeAndSentValueFromMessage)(viewTrace),
        outTraces: viewTrace.outTraces.map(exports.applyTotalFees),
    };
};
exports.applyTotalFees = applyTotalFees;
const calculateTotalFees = (traceTree) => {
    return traceTree.totalFees.plus(traceTree.outTraces
        .map(internalTraceTree => (0, exports.calculateTotalFees)(internalTraceTree))
        .reduce((acc, next) => acc.plus(next), new bignumber_js_1.default(0)));
};
exports.calculateTotalFees = calculateTotalFees;
const printer = ({ type, decodedMsg, contract, totalFees, sentValue, value, balanceChange, error }, { contracts }, printerConfig = {}) => {
    const valueParams = `{valueReceive: ${(0, utils_1.convertForLogger)(value.toNumber())},valueSent: ${(0, utils_1.convertForLogger)(sentValue.toNumber())}, rest: ${(0, utils_1.convertForLogger)(Number(balanceChange.toFixed(10)))}${balanceChange.isLessThan(0) ? chalk_1.default.red("топ") : chalk_1.default.green("том")}, totalFees: ${(0, utils_1.convertForLogger)(totalFees.toNumber())}}`;
    const contractAddress = contract.contract.address.toString();
    const printAddress = "fullPrint" in printerConfig || "printFullAddresses" in printerConfig
        ? contractAddress
        : contractAddress.slice(0, 5) + "..." + contractAddress.slice(-5);
    const header = `${type && exports.mapType[type]}${error ? ` ERROR (phase: ${error.phase}, code: ${error.code})` : ""} ${exports.colors.methodName(printAddress)} ${exports.colors.contractName(contract.name)}.${exports.colors.methodName(decodedMsg?.method)}${type === types_1.TraceType.EVENT ? "" : valueParams}`;
    const printMsg = `${header}(${Object.entries((0, mappers_1.mapParams)(decodedMsg?.params, contracts, "printFillParams" in printerConfig && printerConfig.printFillParams))
        .map(([key, value]) => `${exports.colors.paramsKey(key)}=${JSON.stringify(value)}, `)
        .join("")
        .split(", ")
        .slice(0, -1)
        .join(", ")})`;
    return error ? exports.colors.error(printMsg) : printMsg;
};
exports.printer = printer;
const getBalanceChangingInfo = (viewTrace, accumulator = {}) => {
    const contractAddress = viewTrace.contract?.contract.address.toString();
    if (!(viewTrace.contract?.contract?.address.toString() in accumulator)) {
        accumulator[contractAddress] = {
            totalReceive: new bignumber_js_1.default(0),
            totalSent: new bignumber_js_1.default(0),
        };
    }
    const { totalSent, totalReceive } = accumulator[contractAddress];
    accumulator[contractAddress] = {
        totalReceive: totalReceive.plus(viewTrace.msg.value || 0),
        totalSent: totalSent.plus(viewTrace.sentValue || 0).plus(viewTrace.totalFees),
    };
    return {
        ...accumulator,
        ...viewTrace.outTraces.reduce((acc, next) => {
            return { ...acc, ...(0, exports.getBalanceChangingInfo)(next, accumulator) };
        }, {}),
    };
};
exports.getBalanceChangingInfo = getBalanceChangingInfo;
const getBalanceDiff = (balanceChangeInfo) => {
    return Object.entries(balanceChangeInfo).reduce((acc, [address, { totalSent, totalReceive }]) => {
        return { ...acc, [address]: { balanceDiff: totalReceive.minus(totalSent) } };
    }, {});
};
exports.getBalanceDiff = getBalanceDiff;
const getErrorsInfo = (viewTrace, accumulator = {}) => {
    if (viewTrace.error) {
        const newError = {
            code: viewTrace.error.code,
            phase: viewTrace.error.phase,
            trace: (0, lodash_1.default)(viewTrace).omit("outTraces").value(),
        };
        const address = viewTrace.contract?.contract?.address.toString();
        if (!(address in accumulator)) {
            accumulator[address] = [];
        }
        accumulator[address].push(newError);
    }
    return {
        ...accumulator,
        ...viewTrace.outTraces.reduce((acc, internalTrace) => ({ ...acc, ...(0, exports.getErrorsInfo)(internalTrace, accumulator) }), {}),
    };
};
exports.getErrorsInfo = getErrorsInfo;
const isDesiredMethod = ({ name, type, contract }, trace) => {
    return (type === trace.type &&
        name === trace.decodedMsg?.method &&
        (contract ? (0, utils_1.extractAddress)(contract).equals((0, utils_1.extractAddress)(trace.contract.contract)) : true));
};
exports.isDesiredMethod = isDesiredMethod;
