import { Addressable, BalanceChangeInfoStorage, ErrorStore, MsgError, TraceType, ViewTrace, ViewTraceTree, ViewTraceTreeWithTotalFee } from "../types";
import { Address, Contract, DecodedEventWithTransaction } from "everscale-inpage-provider";
import { AbiEventName } from "everscale-inpage-provider/dist/models";
import { ContractWithName } from "../../../types";
import { PrinterConfig } from "./utils";
import { Tokens } from "./tokens";
export type NameAndType<T extends string = string> = {
    type: TraceType;
    name: T;
    contract?: Addressable;
};
type EventNames<Abi> = DecodedEventWithTransaction<Abi, AbiEventName<Abi>>["event"];
type EventsNamesInner<T extends Contract<any>> = EventNames<T extends Contract<infer f> ? f : never>;
type MethodParams<C extends Contract<any>, N extends keyof C["methods"]> = Parameters<C["methods"][N]>[0];
type EventParams<Abi, N extends string> = Extract<DecodedEventWithTransaction<Abi, AbiEventName<Abi>>, {
    event: N;
}>["data"];
export declare class ViewTracingTree {
    private readonly contractGetter;
    private readonly endpoint;
    readonly viewTraceTree: ViewTraceTreeWithTotalFee;
    readonly tokens: Tokens;
    balanceChangeInfo: BalanceChangeInfoStorage;
    msgErrorsStore: ErrorStore;
    constructor(viewTraceTree: ViewTraceTree, contractGetter: (codeHash: string, address: Address) => ContractWithName<any> | undefined, endpoint: string);
    getErrorsByContract: <T extends string | Address | Contract<any>>(contract: T) => Array<MsgError>;
    getAllErrors: () => {
        phase: "compute" | "action";
        code: number;
        trace: ViewTrace<string, Record<string, any>>;
        contract: string;
    }[];
    getBalanceDiff: <T extends string | Address | Contract<any>>(contracts: T | T[]) => T extends T[] ? Record<string, string> : string;
    findCallsForContract: <C extends Contract<any>, N extends keyof C["methods"] & string>({ contract, name, }: {
        contract: C;
    } & {
        name: N;
    }) => NonNullable<(N extends keyof C["methods"] & string ? MethodParams<C, N> : EventParams<C extends Contract<infer f> ? f : never, N>) | MethodParams<C, N> | undefined>[];
    findEventsForContract: <C extends Contract<any>, Abi extends C extends Contract<infer f> ? f : never, N extends EventNames<Abi>>({ contract, name, }: {
        contract: C;
    } & {
        name: N;
    }) => NonNullable<(N extends keyof C["methods"] & string ? MethodParams<C, N> : EventParams<C extends Contract<infer f_1> ? f_1 : never, N>) | MethodParams<C, N> | undefined>[];
    findForContract: <C extends Contract<any>, N extends (keyof C["methods"] & string) | EventsNamesInner<C>, Abi extends C extends Contract<infer f> ? f : never, E extends N extends keyof C["methods"] & string ? MethodParams<C, N> : EventParams<Abi, N>>({ contract, name, }: {
        contract: C;
    } & {
        name: N;
    }) => (import("../types").DecodedMsg<N, MethodParams<C, N>> | undefined)[] | (import("../types").DecodedMsg<N, E> | undefined)[];
    findByType: <M extends string, P>(params: NameAndType) => (import("../types").DecodedMsg<M, P> | undefined)[];
    findByTypeWithFullData: <M extends string, P>(params: NameAndType) => ViewTrace<M, P>[];
    private _findByType;
    totalGasUsed: () => number;
    beautyPrint: (printerConfig?: PrinterConfig) => Promise<void>;
    private _beautyPrint;
}
export {};
