"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transactions = exports.extractTransactionFromParams = exports.getKeyPairFromSecret = exports.errorExtractor = exports.getRandomNonce = exports.convertAmount = exports.stringToBytesArray = exports.isValidEverAddress = exports.fromNano = exports.toNano = exports.tryLoadTvcFromFile = exports.loadBase64FromFile = exports.loadJSONFromFile = void 0;
const fs_1 = __importDefault(require("fs"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const everscale_crypto_1 = require("everscale-crypto");
const constants_1 = require("../constants");
const loadJSONFromFile = (filePath) => {
    try {
        return JSON.parse(fs_1.default.readFileSync(filePath, "utf8"));
    }
    catch (e) {
        return undefined;
    }
};
exports.loadJSONFromFile = loadJSONFromFile;
const loadBase64FromFile = (filePath) => {
    try {
        return fs_1.default.readFileSync(filePath, "utf8").split("\n").join("");
    }
    catch (e) {
        return undefined;
    }
};
exports.loadBase64FromFile = loadBase64FromFile;
const tryLoadTvcFromFile = (filePath) => {
    try {
        return fs_1.default.readFileSync(filePath, "base64");
    }
    catch (e) {
        return;
    }
};
exports.tryLoadTvcFromFile = tryLoadTvcFromFile;
const toNano = (amount) => new bignumber_js_1.default(amount).shiftedBy(9).toFixed(0);
exports.toNano = toNano;
const fromNano = (amount) => new bignumber_js_1.default(amount).shiftedBy(-9).toString();
exports.fromNano = fromNano;
const isValidEverAddress = (address) => /^(?:-1|0):[0-9a-fA-F]{64}$/.test(address);
exports.isValidEverAddress = isValidEverAddress;
const stringToBytesArray = (dataString, encoding = "base64") => {
    return Buffer.from(dataString).toString(encoding);
};
exports.stringToBytesArray = stringToBytesArray;
const convertAmount = (amount, dimension) => {
    const crystalBN = new bignumber_js_1.default(amount);
    switch (dimension) {
        case constants_1.Dimension.ToNano:
            return crystalBN.times(10 ** 9).toFixed(0);
        case constants_1.Dimension.FromNano:
            return crystalBN.div(new bignumber_js_1.default(10).pow(9)).toString();
    }
};
exports.convertAmount = convertAmount;
const getRandomNonce = () => (Math.random() * 64000) | 0;
exports.getRandomNonce = getRandomNonce;
const errorExtractor = async (transactionResult) => {
    return transactionResult.then(res => {
        if (res.transaction.aborted) {
            throw {
                message: `Transaction aborted with code ${res.transaction.exitCode}`,
                name: "TransactionAborted",
                transaction: res,
            };
        }
        return res;
    });
};
exports.errorExtractor = errorExtractor;
const getKeyPairFromSecret = (secretKey) => {
    return {
        secretKey,
        publicKey: (0, everscale_crypto_1.getPublicKey)(secretKey),
    };
};
exports.getKeyPairFromSecret = getKeyPairFromSecret;
const extractTransactionFromParams = (transaction) => {
    if ("tx" in transaction) {
        return transaction.tx.transaction;
    }
    if ("transaction" in transaction) {
        return transaction.transaction;
    }
    return transaction;
};
exports.extractTransactionFromParams = extractTransactionFromParams;
class Transactions {
    provider;
    constructor(provider) {
        this.provider = provider;
    }
    waitFinalized = async (transactionProm) => {
        const transaction = await transactionProm;
        const subscription = new this.provider.Subscriber();
        return subscription
            .trace((0, exports.extractTransactionFromParams)(transaction))
            .finished()
            .then(subscription.unsubscribe.bind(subscription))
            .then(() => transaction);
    };
}
exports.Transactions = Transactions;
