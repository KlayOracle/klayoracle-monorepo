/* tslint:disable */
/* eslint-disable */
/**
* @param {string} address
* @returns {boolean}
*/
export function checkAddress(address: string): boolean;
/**
* @param {string} address
* @returns {string}
*/
export function repackAddress(address: string): string;
/**
* @param {ClockWithOffset} clock
* @param {string} account_stuff_boc
* @param {string} contract_abi
* @param {string} method
* @param {TokensObject} input
* @param {boolean} responsible
* @param {number | undefined} signature_id
* @returns {ExecutionOutput}
*/
export function runLocal(clock: ClockWithOffset, account_stuff_boc: string, contract_abi: string, method: string, input: TokensObject, responsible: boolean, signature_id?: number): ExecutionOutput;
/**
* @param {string | undefined} account_stuff_boc
* @returns {string}
*/
export function makeFullAccountBoc(account_stuff_boc?: string): string;
/**
* @param {string} account
* @returns {FullContractState | undefined}
*/
export function parseFullAccountBoc(account: string): FullContractState | undefined;
/**
* @param {string} config
* @param {string} account
* @param {string} message
* @param {number} utime
* @param {boolean} disable_signature_check
* @param {string | undefined} overwrite_balance
* @param {number | undefined} global_id
* @returns {TransactionExecutorOutput}
*/
export function executeLocal(config: string, account: string, message: string, utime: number, disable_signature_check: boolean, overwrite_balance?: string, global_id?: number): TransactionExecutorOutput;
/**
* @param {string} tvc
* @param {string} contract_abi
* @param {number} workchain_id
* @param {string | undefined} public_key
* @param {TokensObject} init_data
* @returns {ExpectedAddress}
*/
export function getExpectedAddress(tvc: string, contract_abi: string, workchain_id: number, public_key: string | undefined, init_data: TokensObject): ExpectedAddress;
/**
* @param {string} contract_abi
* @param {string} boc
* @param {boolean} allow_partial
* @returns {TokensObject | undefined}
*/
export function unpackContractFields(contract_abi: string, boc: string, allow_partial: boolean): TokensObject | undefined;
/**
* @param {string} contract_abi
* @param {string} data
* @returns {{ publicKey?: string, data: TokensObject }}
*/
export function unpackInitData(contract_abi: string, data: string): { publicKey?: string, data: TokensObject };
/**
* @param {string} boc
* @returns {string}
*/
export function getBocHash(boc: string): string;
/**
* @param {Array<AbiParam>} params
* @param {TokensObject} tokens
* @param {string | undefined} abi_version
* @returns {{ hash: string, boc: string, }}
*/
export function packIntoCell(params: Array<AbiParam>, tokens: TokensObject, abi_version?: string): { hash: string, boc: string, };
/**
* @param {Array<AbiParam>} params
* @param {string} boc
* @param {boolean} allow_partial
* @param {string | undefined} abi_version
* @returns {TokensObject}
*/
export function unpackFromCell(params: Array<AbiParam>, boc: string, allow_partial: boolean, abi_version?: string): TokensObject;
/**
* @param {string} boc
* @returns {string | undefined}
*/
export function extractContractData(boc: string): string | undefined;
/**
* @param {string} boc
* @returns {string}
*/
export function extractPublicKey(boc: string): string;
/**
* @param {string} code
* @returns {{ hash: string, boc: string, }}
*/
export function codeToTvc(code: string): { hash: string, boc: string, };
/**
* @param {string} code
* @param {string} data
* @returns {{ hash: string, boc: string, }}
*/
export function mergeTvc(code: string, data: string): { hash: string, boc: string, };
/**
* @param {string} tvc
* @returns {StateInit}
*/
export function splitTvc(tvc: string): StateInit;
/**
* @param {string} code
* @param {string} salt
* @returns {{ hash: string, boc: string, }}
*/
export function setCodeSalt(code: string, salt: string): { hash: string, boc: string, };
/**
* @param {string} code
* @returns {string | undefined}
*/
export function getCodeSalt(code: string): string | undefined;
/**
* @param {string} contract_abi
* @param {string} method
* @param {TokensObject} input
* @returns {string}
*/
export function encodeInternalInput(contract_abi: string, method: string, input: TokensObject): string;
/**
* @param {string | undefined} src
* @param {string} dst
* @param {boolean} bounce
* @param {string | undefined} state_init
* @param {string | undefined} body
* @param {string} amount
* @param {boolean | undefined} bounced
* @returns {string}
*/
export function encodeInternalMessage(src: string | undefined, dst: string, bounce: boolean, state_init: string | undefined, body: string | undefined, amount: string, bounced?: boolean): string;
/**
* @param {string} message_body
* @param {string} contract_abi
* @param {MethodName} method
* @param {boolean} internal
* @returns {DecodedInput | undefined}
*/
export function decodeInput(message_body: string, contract_abi: string, method: MethodName, internal: boolean): DecodedInput | undefined;
/**
* @param {string} message_body
* @param {string} contract_abi
* @param {MethodName} event
* @returns {DecodedEvent | undefined}
*/
export function decodeEvent(message_body: string, contract_abi: string, event: MethodName): DecodedEvent | undefined;
/**
* @param {string} message_body
* @param {string} contract_abi
* @param {MethodName} method
* @returns {DecodedOutput | undefined}
*/
export function decodeOutput(message_body: string, contract_abi: string, method: MethodName): DecodedOutput | undefined;
/**
* @param {Transaction} transaction
* @param {string} contract_abi
* @param {MethodName} method
* @returns {DecodedTransaction | undefined}
*/
export function decodeTransaction(transaction: Transaction, contract_abi: string, method: MethodName): DecodedTransaction | undefined;
/**
* @param {Transaction} transaction
* @param {string} contract_abi
* @returns {DecodedTransactionEvents}
*/
export function decodeTransactionEvents(transaction: Transaction, contract_abi: string): DecodedTransactionEvents;
/**
* @param {string} boc
* @returns {TransactionTree}
*/
export function unpackTransactionTree(boc: string): TransactionTree;
/**
* @param {string} data
* @returns {string}
*/
export function getDataHash(data: string): string;
/**
* @returns {Ed25519KeyPair}
*/
export function ed25519_generateKeyPair(): Ed25519KeyPair;
/**
* @param {string} secret_key
* @param {string} data
* @param {number | undefined} signature_id
* @returns {string}
*/
export function ed25519_sign(secret_key: string, data: string, signature_id?: number): string;
/**
* @param {string} signature
* @returns {ExtendedSignature}
*/
export function extendSignature(signature: string): ExtendedSignature;
/**
* @param {string} public_key
* @param {string} data
* @param {string} signature
* @param {number | undefined} signature_id
* @returns {boolean}
*/
export function verifySignature(public_key: string, data: string, signature: string, signature_id?: number): boolean;
/**
* @param {string} dst
* @param {string | undefined} state_init
* @param {string | undefined} body
* @param {number} expire_at
* @returns {SignedMessage}
*/
export function createRawExternalMessage(dst: string, state_init: string | undefined, body: string | undefined, expire_at: number): SignedMessage;
/**
* @param {ClockWithOffset} clock
* @param {string} dst
* @param {string} contract_abi
* @param {string} method
* @param {string | undefined} state_init
* @param {TokensObject} input
* @param {number} timeout
* @returns {SignedMessage}
*/
export function createExternalMessageWithoutSignature(clock: ClockWithOffset, dst: string, contract_abi: string, method: string, state_init: string | undefined, input: TokensObject, timeout: number): SignedMessage;
/**
* @param {ClockWithOffset} clock
* @param {string} dst
* @param {string} contract_abi
* @param {string} method
* @param {string | undefined} state_init
* @param {TokensObject} input
* @param {string} public_key
* @param {number} timeout
* @returns {UnsignedMessage}
*/
export function createExternalMessage(clock: ClockWithOffset, dst: string, contract_abi: string, method: string, state_init: string | undefined, input: TokensObject, public_key: string, timeout: number): UnsignedMessage;

export interface IGqlSender {
  isLocal(): boolean;
  send(data: string, handler: GqlQuery, long_query: boolean): void;
}



export type ExecutorParams = {
    disableSignatureCheck?: boolean,
    overrideBalance?: string | number,
};



export type NetworkDescription = {
    globalId: number,
    capabilities: string,
    signatureId: number | undefined,
};

export type TransactionId = {
    lt: string,
    hash: string,
};

export type GenTimings = {
    genLt: string,
    genUtime: number,
};

export type LastTransactionId = {
    isExact: boolean,
    lt: string,
    hash?: string,
};

export type ContractState = {
    balance: string,
    genTimings: GenTimings,
    lastTransactionId?: LastTransactionId,
    isDeployed: boolean,
    codeHash?: string,
};

export type AccountStatus = 'uninit' | 'frozen' | 'active' | 'nonexist';

export type Message = {
    hash: string,
    src?: string,
    dst?: string,
    value: string,
    bounce: boolean,
    bounced: boolean,
    body?: string,
    bodyHash?: string,
};

export type PendingTransaction = {
    messageHash: string,
    src?: string,
    expireAt: number,
};

export type AccountsList = {
  accounts: string[];
  continuation: string | undefined;
};

export type TransactionsList = {
    transactions: Transaction[];
    continuation: TransactionId | undefined;
};

export type Transaction = {
    id: TransactionId,
    prevTransactionId?: TransactionId,
    createdAt: number,
    aborted: boolean,
    exitCode?: number,
    resultCode?: number,
    origStatus: AccountStatus,
    endStatus: AccountStatus,
    totalFees: string,
    inMessage: Message,
    outMessages: Message[],
};

export type TransactionsBatchType = 'old' | 'new';

export type TransactionsBatchInfo = {
    minLt: string,
    maxLt: string,
    batchType: TransactionsBatchType,
};

export type StateInit = {
    data: string | undefined;
    code: string | undefined;
};

export type ExpectedAddress = {
    stateInit: string;
    address: string;
    hash: string;
};

export type DecodedInput = {
    method: string,
    input: TokensObject,
};

export type DecodedEvent = {
    event: string,
    data: TokensObject,
};

export type DecodedOutput = {
    method: string,
    output: TokensObject,
};

export type DecodedTransaction = {
    method: string,
    input: TokensObject,
    output: TokensObject,
};

export type DecodedTransactionEvents = Array<DecodedEvent>;

export type TransactionExecutorOutput =
    | { exitCode: number }
    | { account: string, transaction: Transaction };

export type ExecutionOutput = {
    output?: TokensObject,
    code: number,
};

export type MethodName = undefined | string | string[];

export type AbiToken =
    | null
    | boolean
    | string
    | number
    | { [K in string]: AbiToken }
    | AbiToken[]
    | (readonly [AbiToken, AbiToken])[];

type TokensObject = { [K in string]: AbiToken };

export type AbiParam = {
  name: string;
  type: string;
  components?: AbiParam[];
};

export type LatestBlock = {
    id: string,
    endLt: string,
    genUtime: number,
};

export type SignedMessage = {
    hash: string,
    expireAt: number,
    boc: string,
};

export type PollingMethod = 'manual' | 'reliable';

export type Ed25519KeyPair = {
    publicKey: string,
    secretKey: string,
};

export type ExtendedSignature = {
    signature: string,
    signatureHex: string,
    signatureParts: {
        high: string,
        low: string,
    }
};

export type FullContractState = {
    balance: string;
    genTimings: GenTimings;
    lastTransactionId: LastTransactionId;
    isDeployed: boolean;
    codeHash?: string;
    boc: string;
};

export type TransactionTree = {
    root: Transaction,
    children: TransactionTree[]
};




export type EnumItem<T extends string, D> = { type: T, data: D };


/**
*/
export class ClockWithOffset {
  free(): void;
/**
*/
  constructor();
/**
* @param {number} offset_ms
*/
  updateOffset(offset_ms: number): void;
/**
* @returns {number}
*/
  offsetMs(): number;
/**
*/
  readonly nowMs: number;
}
/**
*/
export class GenericContract {
  free(): void;
/**
* @param {SignedMessage} message
* @param {ExecutorParams | undefined} params
* @returns {Promise<Transaction>}
*/
  sendMessageLocally(message: SignedMessage, params: ExecutorParams | undefined): Promise<Transaction>;
/**
* @param {SignedMessage} message
* @returns {Promise<PendingTransaction>}
*/
  sendMessage(message: SignedMessage): Promise<PendingTransaction>;
/**
* @returns {Promise<PollingMethod>}
*/
  refresh(): Promise<PollingMethod>;
/**
* @param {string} block_id
* @returns {Promise<PollingMethod>}
*/
  handleBlock(block_id: string): Promise<PollingMethod>;
/**
* @param {string} lt
* @returns {Promise<void>}
*/
  preloadTransactions(lt: string): Promise<void>;
/**
*/
  readonly address: string;
/**
*/
  readonly pollingMethod: PollingMethod;
}
/**
*/
export class GqlConnection {
  free(): void;
/**
* @param {ClockWithOffset} clock
* @param {IGqlSender} sender
*/
  constructor(clock: ClockWithOffset, sender: IGqlSender);
/**
* @param {string} address
* @returns {Promise<LatestBlock>}
*/
  getLatestBlock(address: string): Promise<LatestBlock>;
/**
* @param {string} current_block_id
* @param {string} address
* @param {number} timeout
* @returns {Promise<string>}
*/
  waitForNextBlock(current_block_id: string, address: string, timeout: number): Promise<string>;
}
/**
*/
export class GqlQuery {
  free(): void;
/**
* @param {string} data
*/
  onReceive(data: string): void;
/**
* @param {any} arg0
*/
  onError(arg0: any): void;
/**
*/
  onTimeout(): void;
}
/**
*/
export class JrpcConnection {
  free(): void;
/**
* @param {ClockWithOffset} clock
* @param {any} sender
*/
  constructor(clock: ClockWithOffset, sender: any);
}
/**
*/
export class JrpcQuery {
  free(): void;
/**
* @param {string} data
*/
  onReceive(data: string): void;
/**
* @param {any} arg0
*/
  onError(arg0: any): void;
/**
*/
  onTimeout(): void;
}
/**
*/
export class Transport {
  free(): void;
/**
* @param {GqlConnection} gql
* @returns {Transport}
*/
  static fromGqlConnection(gql: GqlConnection): Transport;
/**
* @param {JrpcConnection} jrpc
* @returns {Transport}
*/
  static fromJrpcConnection(jrpc: JrpcConnection): Transport;
/**
* @returns {Promise<NetworkDescription>}
*/
  getNetworkDescription(): Promise<NetworkDescription>;
/**
* @returns {Promise<number | undefined>}
*/
  getSignatureId(): Promise<number | undefined>;
/**
* @param {boolean | undefined} force
* @returns {Promise<string>}
*/
  getBlockchainConfig(force?: boolean): Promise<string>;
/**
* @param {string} address
* @param {any} handler
* @returns {Promise<GenericContract>}
*/
  subscribeToGenericContract(address: string, handler: any): Promise<GenericContract>;
/**
* @param {string} address
* @returns {Promise<FullContractState | undefined>}
*/
  getFullContractState(address: string): Promise<FullContractState | undefined>;
/**
* @param {string} code_hash
* @param {number} limit
* @param {string | undefined} continuation
* @returns {Promise<AccountsList>}
*/
  getAccountsByCodeHash(code_hash: string, limit: number, continuation?: string): Promise<AccountsList>;
/**
* @param {string} address
* @param {string | undefined} continuation
* @param {number} limit
* @returns {Promise<TransactionsList>}
*/
  getTransactions(address: string, continuation: string | undefined, limit: number): Promise<TransactionsList>;
/**
* @param {string} hash
* @returns {Promise<Transaction | undefined>}
*/
  getTransaction(hash: string): Promise<Transaction | undefined>;
/**
* @param {string} message_hash
* @returns {Promise<Transaction | undefined>}
*/
  getDstTransaction(message_hash: string): Promise<Transaction | undefined>;
}
/**
*/
export class UnsignedMessage {
  free(): void;
/**
* @param {ClockWithOffset} clock
*/
  refreshTimeout(clock: ClockWithOffset): void;
/**
* @returns {number}
*/
  expireAt(): number;
/**
* @param {string} signature
* @returns {SignedMessage}
*/
  sign(signature: string): SignedMessage;
/**
* @returns {SignedMessage}
*/
  signFake(): SignedMessage;
/**
*/
  readonly hash: string;
}

export type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;

export interface InitOutput {
  readonly memory: WebAssembly.Memory;
  readonly __wbg_gqlquery_free: (a: number) => void;
  readonly gqlquery_onReceive: (a: number, b: number, c: number) => void;
  readonly gqlquery_onError: (a: number, b: number) => void;
  readonly gqlquery_onTimeout: (a: number) => void;
  readonly __wbg_genericcontract_free: (a: number) => void;
  readonly genericcontract_address: (a: number, b: number) => void;
  readonly genericcontract_sendMessageLocally: (a: number, b: number, c: number, d: number) => void;
  readonly genericcontract_sendMessage: (a: number, b: number, c: number) => void;
  readonly genericcontract_refresh: (a: number) => number;
  readonly genericcontract_handleBlock: (a: number, b: number, c: number) => number;
  readonly genericcontract_preloadTransactions: (a: number, b: number, c: number, d: number) => void;
  readonly genericcontract_pollingMethod: (a: number) => number;
  readonly __wbg_unsignedmessage_free: (a: number) => void;
  readonly unsignedmessage_refreshTimeout: (a: number, b: number) => void;
  readonly unsignedmessage_expireAt: (a: number) => number;
  readonly unsignedmessage_hash: (a: number, b: number) => void;
  readonly unsignedmessage_sign: (a: number, b: number, c: number, d: number) => void;
  readonly unsignedmessage_signFake: (a: number, b: number) => void;
  readonly __wbg_gqlconnection_free: (a: number) => void;
  readonly gqlconnection_new: (a: number, b: number) => number;
  readonly gqlconnection_getLatestBlock: (a: number, b: number, c: number, d: number) => void;
  readonly gqlconnection_waitForNextBlock: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly __wbg_transport_free: (a: number) => void;
  readonly transport_fromGqlConnection: (a: number) => number;
  readonly transport_fromJrpcConnection: (a: number) => number;
  readonly transport_getNetworkDescription: (a: number) => number;
  readonly transport_getSignatureId: (a: number) => number;
  readonly transport_getBlockchainConfig: (a: number, b: number) => number;
  readonly transport_subscribeToGenericContract: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly transport_getFullContractState: (a: number, b: number, c: number, d: number) => void;
  readonly transport_getAccountsByCodeHash: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly transport_getTransactions: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly transport_getTransaction: (a: number, b: number, c: number, d: number) => void;
  readonly transport_getDstTransaction: (a: number, b: number, c: number, d: number) => void;
  readonly __wbg_clockwithoffset_free: (a: number) => void;
  readonly clockwithoffset_new: () => number;
  readonly clockwithoffset_nowMs: (a: number) => number;
  readonly clockwithoffset_updateOffset: (a: number, b: number) => void;
  readonly clockwithoffset_offsetMs: (a: number) => number;
  readonly checkAddress: (a: number, b: number) => number;
  readonly repackAddress: (a: number, b: number, c: number) => void;
  readonly runLocal: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number) => void;
  readonly makeFullAccountBoc: (a: number, b: number, c: number) => void;
  readonly parseFullAccountBoc: (a: number, b: number, c: number) => void;
  readonly executeLocal: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number, m: number) => void;
  readonly getExpectedAddress: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => void;
  readonly unpackContractFields: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly unpackInitData: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly getBocHash: (a: number, b: number, c: number) => void;
  readonly packIntoCell: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly unpackFromCell: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly extractContractData: (a: number, b: number, c: number) => void;
  readonly extractPublicKey: (a: number, b: number, c: number) => void;
  readonly codeToTvc: (a: number, b: number, c: number) => void;
  readonly mergeTvc: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly splitTvc: (a: number, b: number, c: number) => void;
  readonly setCodeSalt: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly getCodeSalt: (a: number, b: number, c: number) => void;
  readonly encodeInternalInput: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly encodeInternalMessage: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number, m: number) => void;
  readonly decodeInput: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly decodeEvent: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly decodeOutput: (a: number, b: number, c: number, d: number, e: number, f: number) => void;
  readonly decodeTransaction: (a: number, b: number, c: number, d: number, e: number) => void;
  readonly decodeTransactionEvents: (a: number, b: number, c: number, d: number) => void;
  readonly unpackTransactionTree: (a: number, b: number, c: number) => void;
  readonly getDataHash: (a: number, b: number, c: number) => void;
  readonly ed25519_generateKeyPair: (a: number) => void;
  readonly ed25519_sign: (a: number, b: number, c: number, d: number, e: number, f: number, g: number) => void;
  readonly extendSignature: (a: number, b: number, c: number) => void;
  readonly verifySignature: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number) => void;
  readonly createRawExternalMessage: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number) => void;
  readonly createExternalMessageWithoutSignature: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number) => void;
  readonly createExternalMessage: (a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number, l: number, m: number, n: number) => void;
  readonly jrpcconnection_new: (a: number, b: number) => number;
  readonly __wbg_jrpcconnection_free: (a: number) => void;
  readonly __wbg_jrpcquery_free: (a: number) => void;
  readonly jrpcquery_onTimeout: (a: number) => void;
  readonly jrpcquery_onError: (a: number, b: number) => void;
  readonly jrpcquery_onReceive: (a: number, b: number, c: number) => void;
  readonly __wbindgen_malloc: (a: number) => number;
  readonly __wbindgen_realloc: (a: number, b: number, c: number) => number;
  readonly __wbindgen_export_2: WebAssembly.Table;
  readonly _dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hf773c3d7bb6081c6: (a: number, b: number, c: number) => void;
  readonly __wbindgen_add_to_stack_pointer: (a: number) => number;
  readonly __wbindgen_free: (a: number, b: number) => void;
  readonly __wbindgen_exn_store: (a: number) => void;
  readonly wasm_bindgen__convert__closures__invoke2_mut__h9bec1e94e3cdfbe9: (a: number, b: number, c: number, d: number) => void;
}

export type SyncInitInput = BufferSource | WebAssembly.Module;
/**
* Instantiates the given `module`, which can either be bytes or
* a precompiled `WebAssembly.Module`.
*
* @param {SyncInitInput} module
*
* @returns {InitOutput}
*/
export function initSync(module: SyncInitInput): InitOutput;

/**
* If `module_or_path` is {RequestInfo} or {URL}, makes a request and
* for everything else, calls `WebAssembly.instantiate` directly.
*
* @param {InitInput | Promise<InitInput>} module_or_path
*
* @returns {Promise<InitOutput>}
*/
export default function __wbg_init (module_or_path?: InitInput | Promise<InitInput>): Promise<InitOutput>;
